{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes, refHandler, setRef } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\n\nvar Popover =\n/** @class */\nfunction (_super) {\n  __extends(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // eslint-disable-next-line deprecation/deprecation\n\n\n    _this.popoverRef = React.createRef();\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props),\n      transformOrigin: \"\"\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n    _this.handlePopoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n\n    _this.handleTargetRef = function (ref) {\n      return _this.targetElement = ref;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b = _this.props,\n          interactionKind = _b.interactionKind,\n          usePortal = _b.usePortal;\n      var transformOrigin = _this.state.transformOrigin; // Need to update our reference to this on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.scheduleUpdate;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick\n      };\n\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER_OUT_OF_BOUNDARIES] = popperProps.outOfBoundaries === true, _a), _this.props.popoverClassName);\n      return React.createElement(\"div\", {\n        className: Classes.TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.understandChildren().content))));\n    };\n\n    _this.renderTarget = function (referenceProps) {\n      var _a, _b;\n\n      var _c = _this.props,\n          fill = _c.fill,\n          openOnTargetFocus = _c.openOnTargetFocus,\n          targetClassName = _c.targetClassName,\n          _d = _c.targetProps,\n          targetProps = _d === void 0 ? {} : _d;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      var finalTargetProps = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick\n      };\n      finalTargetProps[\"aria-haspopup\"] = \"true\";\n      finalTargetProps.className = classNames(Classes.POPOVER_TARGET, (_a = {}, _a[Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\n      finalTargetProps.ref = referenceProps.ref;\n      var rawTarget = Utils.ensureElement(_this.understandChildren().target);\n\n      if (rawTarget === undefined) {\n        return null;\n      }\n\n      var rawTabIndex = rawTarget.props.tabIndex; // ensure target is focusable if relevant prop enabled\n\n      var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n      var clonedTarget = React.cloneElement(rawTarget, {\n        className: classNames(rawTarget.props.className, (_b = {}, // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n        // when they are opened by a user interaction\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n\n        /* eslint-disable-next-line deprecation/deprecation */\n        disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n        tabIndex: tabIndex\n      });\n      var target = React.createElement(targetTagName, __assign(__assign({}, targetProps), finalTargetProps), clonedTarget);\n      return React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n\n    _this.handleTargetFocus = function (e) {\n      var _a, _b;\n\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleTargetBlur = function (e) {\n      var _a, _b;\n\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        // if the next element to receive focus is within the popover, we'll want to leave the\n        // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n        // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n        // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n        // close the popover if necessary.\n        if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n          _this.handleMouseLeave(e);\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleMouseEnter = function (e) {\n      var _a, _b;\n\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleMouseLeave = function (e) {\n      var _a, _b;\n\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var isEventFromSelf = eventPopover === _this.popoverRef.current;\n      var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS); // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(Classes.DISABLED)) != null;\n\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      var _a, _b; // ensure click did not originate from within inline popover before closing\n\n\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n\n\n    _this.updatePopoverState = function (data) {\n      // always set string; let shouldComponentUpdate determine if update is necessary\n      _this.setState({\n        transformOrigin: getTransformOrigin(data)\n      });\n\n      return data;\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var _a;\n\n    var _b; // rename wrapper tag to begin with uppercase letter so it's recognized\n    // as JSX component instead of intrinsic element. but because of its\n    // type, tsc actually recognizes that it is _any_ intrinsic element, so\n    // it can typecheck the HTML props!!\n\n\n    var _c = this.props,\n        className = _c.className,\n        disabled = _c.disabled,\n        fill = _c.fill,\n        placement = _c.placement,\n        _d = _c.position,\n        position = _d === void 0 ? \"auto\" : _d,\n        shouldReturnFocusOnClose = _c.shouldReturnFocusOnClose;\n    var isOpen = this.state.isOpen;\n    var wrapperTagName = this.props.wrapperTagName;\n\n    if (fill) {\n      wrapperTagName = \"div\";\n    }\n\n    var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null; // need to do this check in render(), because `isOpen` is derived from\n    // state, and state can't necessarily be accessed in validateProps.\n\n    if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n      console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n    }\n\n    var wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, (_a = {}, _a[Classes.FILL] = fill, _a));\n    var defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n    var wrapper = React.createElement(wrapperTagName, {\n      className: wrapperClasses\n    }, React.createElement(Reference, {\n      innerRef: this.handleTargetRef\n    }, this.renderTarget), React.createElement(Overlay, {\n      autoFocus: (_b = this.props.autoFocus) !== null && _b !== void 0 ? _b : defaultAutoFocus,\n      backdropClassName: Classes.POPOVER_BACKDROP,\n      backdropProps: this.props.backdropProps,\n      canEscapeKeyClose: this.props.canEscapeKeyClose,\n      canOutsideClickClose: this.props.interactionKind === PopoverInteractionKind.CLICK,\n      className: this.props.portalClassName,\n      enforceFocus: this.props.enforceFocus,\n      hasBackdrop: this.props.hasBackdrop,\n      isOpen: isOpen && !isContentEmpty,\n      onClose: this.handleOverlayClose,\n      onClosed: this.props.onClosed,\n      onClosing: this.props.onClosing,\n      onOpened: this.props.onOpened,\n      onOpening: this.props.onOpening,\n      transitionDuration: this.props.transitionDuration,\n      transitionName: Classes.POPOVER,\n      usePortal: this.props.usePortal,\n      portalContainer: this.props.portalContainer,\n      // if hover interaciton, it doesn't make sense to take over focus control\n      shouldReturnFocusOnClose: this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose\n    }, React.createElement(Popper, {\n      innerRef: this.handlePopoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover)));\n    return React.createElement(Manager, null, wrapper);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    if (prevProps.popoverRef !== this.props.popoverRef) {\n      setRef(prevProps.popoverRef, null);\n      this.handlePopoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n      setRef(this.props.popoverRef, this.popoverElement);\n    }\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasContentProp = props.content !== undefined;\n    var hasTargetProp = props.target !== undefined;\n\n    if (childrenCount === 0 && !hasTargetProp) {\n      console.error(Errors.POPOVER_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 2) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n\n    if (childrenCount === 2 && hasContentProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n    }\n  };\n\n  Popover.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\".concat(Classes.DARK)) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  }; // content and target can be specified as props or as children. this method\n  // normalizes the two approaches, preferring child over prop.\n\n\n  Popover.prototype.understandChildren = function () {\n    var _a = this.props,\n        children = _a.children,\n        contentProp = _a.content,\n        targetProp = _a.target; // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n\n    var _b = React.Children.toArray(children),\n        targetChild = _b[0],\n        contentChild = _b[1];\n\n    return {\n      content: contentChild == null ? contentProp : contentChild,\n      target: targetChild == null ? targetProp : targetChild\n    };\n  };\n\n  Popover.prototype.getIsOpen = function (props) {\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else if (props.isOpen != null) {\n      return props.isOpen;\n    } else {\n      return props.defaultIsOpen;\n    }\n  };\n\n  Popover.prototype.getPopperModifiers = function () {\n    var _a = this.props,\n        boundary = _a.boundary,\n        modifiers = _a.modifiers;\n    var _b = modifiers,\n        _c = _b.flip,\n        flip = _c === void 0 ? {} : _c,\n        _d = _b.preventOverflow,\n        preventOverflow = _d === void 0 ? {} : _d;\n    return __assign(__assign({}, modifiers), {\n      arrowOffset: {\n        enabled: this.isArrowEnabled(),\n        fn: arrowOffsetModifier,\n        order: 510\n      },\n      flip: __assign({\n        boundariesElement: boundary\n      }, flip),\n      preventOverflow: __assign({\n        boundariesElement: boundary\n      }, preventOverflow),\n      updatePopoverState: {\n        enabled: true,\n        fn: this.updatePopoverState,\n        order: 900\n      }\n    });\n  }; // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover.prototype.isArrowEnabled = function () {\n    var _a = this.props,\n        minimal = _a.minimal,\n        modifiers = _a.modifiers; // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n\n    return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\n  };\n\n  Popover.prototype.isElementInPopover = function (element) {\n    var _a;\n\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.contains(element);\n  };\n\n  Popover.prototype.isHoverInteractionKind = function () {\n    return this.props.interactionKind === PopoverInteractionKind.HOVER || this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n  };\n\n  Popover.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover\");\n  Popover.defaultProps = {\n    boundary: \"scrollParent\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    minimal: false,\n    modifiers: {},\n    openOnTargetFocus: true,\n    shouldReturnFocusOnClose: false,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true,\n    wrapperTagName: \"span\"\n  };\n  return Popover;\n}(AbstractPureComponent2);\n\nexport { Popover };","map":{"version":3,"mappings":"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","names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent2","Classes","refHandler","setRef","Errors","DISPLAYNAME_PREFIX","Utils","Overlay","ResizeSensor","Tooltip","PopoverArrow","positionToPlacement","arrowOffsetModifier","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","__extends","_this","createRef","hasDarkParent","isOpen","getIsOpen","props","transformOrigin","popoverRef","ref","targetElement","popperScheduleUpdate","_a","popperProps","interactionKind","usePortal","state","scheduleUpdate","popoverHandlers","onClick","handlePopoverClick","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","popoverClasses","POPOVER","DARK","inheritDarkTheme","MINIMAL","minimal","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_OUT_OF_BOUNDARIES","outOfBoundaries","popoverClassName","className","TRANSITION_CONTAINER","style","onResize","reposition","isArrowEnabled","arrowProps","placement","POPOVER_CONTENT","understandChildren","content","referenceProps","fill","openOnTargetFocus","targetClassName","_d","targetProps","isControlled","isHoverInteractionKind","targetTagName","finalTargetProps","onBlur","handleTargetBlur","onFocus","handleTargetFocus","handleTargetClick","POPOVER_TARGET","POPOVER_OPEN","rawTarget","ensureElement","target","undefined","rawTabIndex","tabIndex","clonedTarget","cloneElement","_b","ACTIVE","disabled","isElementOfType","createElement","__assign","e","relatedTarget","lostFocusOnSamePage","isElementInPopover","isMouseInTargetOrPopover","setOpenState","hoverOpenDelay","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","isEventFromSelf","current","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","concat","POPOVER_DISMISS_OVERRIDE","shouldDismiss","isDisabled","DISABLED","elementIsOrContains","nativeEvent","KeyboardEvent","setState","prevState","data","Popover","position","shouldReturnFocusOnClose","wrapperTagName","isContentEmpty","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","wrapperClasses","POPOVER_WRAPPER","FILL","defaultAutoFocus","wrapper","innerRef","handleTargetRef","renderTarget","autoFocus","backdropClassName","POPOVER_BACKDROP","backdropProps","canEscapeKeyClose","canOutsideClickClose","portalClassName","enforceFocus","hasBackdrop","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalContainer","handlePopoverRef","modifiers","getPopperModifiers","renderPopover","updateDarkParent","prevProps","_super","componentDidUpdate","call","popoverElement","nextIsOpen","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","error","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","Children","count","children","hasContentProp","hasTargetProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_DOUBLE_CONTENT","contentProp","targetProp","toArray","targetChild","contentChild","defaultIsOpen","boundary","_c","flip","preventOverflow","arrowOffset","enabled","fn","order","boundariesElement","updatePopoverState","timeout","cancelOpenTimeout","_e","arrow","element"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/components/popover/popover.tsx"],"sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { ModifierFn } from \"popper.js\";\nimport * as React from \"react\";\nimport { Manager, Popper, PopperChildrenProps, Reference, ReferenceChildrenProps } from \"react-popper\";\n\nimport { AbstractPureComponent2, Classes, IRef, refHandler, setRef } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, HTMLDivProps } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { IPopoverSharedProps, PopperModifiers } from \"./popoverSharedProps\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as \"click\",\n    CLICK_TARGET_ONLY: \"click-target\" as \"click-target\",\n    HOVER: \"hover\" as \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\" as \"hover-target\",\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type PopoverInteractionKind = typeof PopoverInteractionKind[keyof typeof PopoverInteractionKind];\n\nexport interface IPopoverProps extends IPopoverSharedProps {\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The content displayed inside the popover. This can instead be provided as\n     * the _second_ element in `children` (first is `target`).\n     */\n    content?: string | JSX.Element;\n\n    /**\n     * Whether the wrapper and target should take up the full width of their container.\n     * Note that supplying `true` for this prop will force  `targetTagName=\"div\"` and\n     * `wrapperTagName=\"div\"`.\n     */\n    fill?: boolean;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default PopoverInteractionKind.CLICK\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set to `false` if this is a hover interaction popover.\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Ref supplied to the `Classes.POPOVER` element.\n     */\n    popoverRef?: IRef<HTMLElement>;\n\n    /**\n     * The target to which the popover content is attached. This can instead be\n     * provided as the _first_ element in `children`.\n     */\n    target?: string | JSX.Element;\n}\n\nexport interface IPopoverState {\n    transformOrigin: string;\n    isOpen: boolean;\n    hasDarkParent: boolean;\n}\n\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\nexport class Popover extends AbstractPureComponent2<IPopoverProps, IPopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    // eslint-disable-next-line deprecation/deprecation\n    private popoverRef = React.createRef<HTMLDivElement>();\n\n    public static defaultProps: IPopoverProps = {\n        boundary: \"scrollParent\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        minimal: false,\n        modifiers: {},\n        openOnTargetFocus: true,\n        shouldReturnFocusOnClose: false,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n        wrapperTagName: \"span\",\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** DOM element that contains the target. */\n    public targetElement: HTMLElement | null = null;\n\n    public state: IPopoverState = {\n        hasDarkParent: false,\n        isOpen: this.getIsOpen(this.props),\n        transformOrigin: \"\",\n    };\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => void;\n\n    private handlePopoverRef: IRef<HTMLElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    private handleTargetRef = (ref: HTMLElement | null) => (this.targetElement = ref);\n\n    public render() {\n        // rename wrapper tag to begin with uppercase letter so it's recognized\n        // as JSX component instead of intrinsic element. but because of its\n        // type, tsc actually recognizes that it is _any_ intrinsic element, so\n        // it can typecheck the HTML props!!\n        const { className, disabled, fill, placement, position = \"auto\", shouldReturnFocusOnClose } = this.props;\n        const { isOpen } = this.state;\n        let { wrapperTagName } = this.props;\n        if (fill) {\n            wrapperTagName = \"div\";\n        }\n\n        const isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\n        // need to do this check in render(), because `isOpen` is derived from\n        // state, and state can't necessarily be accessed in validateProps.\n        if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n            console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n        }\n\n        const wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, {\n            [Classes.FILL]: fill,\n        });\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n\n        const wrapper = React.createElement(\n            wrapperTagName!,\n            { className: wrapperClasses },\n            <Reference innerRef={this.handleTargetRef}>{this.renderTarget}</Reference>,\n            <Overlay\n                autoFocus={this.props.autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={this.props.backdropProps}\n                canEscapeKeyClose={this.props.canEscapeKeyClose}\n                canOutsideClickClose={this.props.interactionKind === PopoverInteractionKind.CLICK}\n                className={this.props.portalClassName}\n                enforceFocus={this.props.enforceFocus}\n                hasBackdrop={this.props.hasBackdrop}\n                isOpen={isOpen && !isContentEmpty}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={this.props.usePortal}\n                portalContainer={this.props.portalContainer}\n                // if hover interaciton, it doesn't make sense to take over focus control\n                shouldReturnFocusOnClose={this.isHoverInteractionKind() ? false : shouldReturnFocusOnClose}\n            >\n                <Popper\n                    innerRef={this.handlePopoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Overlay>,\n        );\n\n        return <Manager>{wrapper}</Manager>;\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(prevProps: IPopoverProps, prevState: IPopoverState) {\n        super.componentDidUpdate(prevProps, prevState);\n\n        if (prevProps.popoverRef !== this.props.popoverRef) {\n            setRef(prevProps.popoverRef, null);\n            this.handlePopoverRef = refHandler(this, \"popoverElement\", this.props.popoverRef);\n            setRef(this.props.popoverRef, this.popoverElement);\n        }\n\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    protected validateProps(props: IPopoverProps & { children?: React.ReactNode }) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasContentProp = props.content !== undefined;\n        const hasTargetProp = props.target !== undefined;\n\n        if (childrenCount === 0 && !hasTargetProp) {\n            console.error(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 2) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (childrenCount === 2 && hasContentProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent = this.targetElement != null && this.targetElement.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { interactionKind, usePortal } = this.props;\n        const { transformOrigin } = this.state;\n\n        // Need to update our reference to this on every render as it will change.\n        this.popperScheduleUpdate = popperProps.scheduleUpdate;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_OUT_OF_BOUNDARIES]: popperProps.outOfBoundaries === true,\n            },\n            this.props.popoverClassName,\n        );\n\n        return (\n            <div className={Classes.TRANSITION_CONTAINER} ref={popperProps.ref} style={popperProps.style}>\n                <ResizeSensor onResize={this.reposition}>\n                    <div\n                        className={popoverClasses}\n                        style={{ transformOrigin }}\n                        ref={this.popoverRef}\n                        {...popoverHandlers}\n                    >\n                        {this.isArrowEnabled() && (\n                            <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                        )}\n                        <div className={Classes.POPOVER_CONTENT}>{this.understandChildren().content}</div>\n                    </div>\n                </ResizeSensor>\n            </div>\n        );\n    };\n\n    private renderTarget = (referenceProps: ReferenceChildrenProps) => {\n        const { fill, openOnTargetFocus, targetClassName, targetProps = {} } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        const finalTargetProps: React.HTMLProps<HTMLElement> = isHoverInteractionKind\n            ? {\n                  // HOVER handlers\n                  onBlur: this.handleTargetBlur,\n                  onFocus: this.handleTargetFocus,\n                  onMouseEnter: this.handleMouseEnter,\n                  onMouseLeave: this.handleMouseLeave,\n              }\n            : {\n                  // CLICK needs only one handler\n                  onClick: this.handleTargetClick,\n              };\n        finalTargetProps[\"aria-haspopup\"] = \"true\";\n        finalTargetProps.className = classNames(\n            Classes.POPOVER_TARGET,\n            { [Classes.POPOVER_OPEN]: isOpen },\n            targetProps.className,\n            targetClassName,\n        );\n        finalTargetProps.ref = referenceProps.ref;\n\n        const rawTarget = Utils.ensureElement(this.understandChildren().target);\n\n        if (rawTarget === undefined) {\n            return null;\n        }\n\n        const rawTabIndex = rawTarget.props.tabIndex;\n        // ensure target is focusable if relevant prop enabled\n        const tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n        const clonedTarget: JSX.Element = React.cloneElement(rawTarget, {\n            className: classNames(rawTarget.props.className, {\n                // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n                // when they are opened by a user interaction\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n            /* eslint-disable-next-line deprecation/deprecation */\n            disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n            tabIndex,\n        });\n        const target = React.createElement(\n            targetTagName!,\n            {\n                ...targetProps,\n                ...finalTargetProps,\n            },\n            clonedTarget,\n        );\n\n        return <ResizeSensor onResize={this.reposition}>{target}</ResizeSensor>;\n    };\n\n    // content and target can be specified as props or as children. this method\n    // normalizes the two approaches, preferring child over prop.\n    private understandChildren() {\n        const { children, content: contentProp, target: targetProp } = this.props;\n        // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n        const [targetChild, contentChild] = React.Children.toArray(children);\n        return {\n            content: contentChild == null ? contentProp : contentChild,\n            target: targetChild == null ? targetProp : targetChild,\n        };\n    }\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    private getIsOpen(props: IPopoverProps) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else if (props.isOpen != null) {\n            return props.isOpen;\n        } else {\n            return props.defaultIsOpen!;\n        }\n    }\n\n    private getPopperModifiers(): PopperModifiers {\n        const { boundary, modifiers } = this.props;\n        const { flip = {}, preventOverflow = {} } = modifiers!;\n        return {\n            ...modifiers,\n            arrowOffset: {\n                enabled: this.isArrowEnabled(),\n                fn: arrowOffsetModifier,\n                order: 510,\n            },\n            flip: { boundariesElement: boundary, ...flip },\n            preventOverflow: { boundariesElement: boundary, ...preventOverflow },\n            updatePopoverState: {\n                enabled: true,\n                fn: this.updatePopoverState,\n                order: 900,\n            },\n        };\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n        this.props.targetProps?.onFocus?.(e);\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            // if the next element to receive focus is within the popover, we'll want to leave the\n            // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n            // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n            // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n            // close the popover if necessary.\n            if (e.relatedTarget != null && !this.isElementInPopover(e.relatedTarget as HTMLElement)) {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n        this.props.targetProps?.onBlur?.(e);\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n        this.props.targetProps?.onMouseEnter?.(e);\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa).\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n        this.props.targetProps?.onMouseLeave?.(e);\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = eventPopover === this.popoverRef.current;\n        const isEventPopoverCapturing = eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS);\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        const shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetElement === null || e === undefined) {\n            return;\n        }\n\n        const eventTarget = e.target as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement>) => {\n        // ensure click did not originate from within inline popover before closing\n        if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n            if (this.props.isOpen == null) {\n                this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n            } else {\n                this.setOpenState(!this.props.isOpen, e);\n            }\n        }\n        this.props.targetProps?.onClick?.(e);\n    };\n\n    // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(() => this.setOpenState(isOpen, e), timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n            }\n        }\n    }\n\n    private isArrowEnabled() {\n        const { minimal, modifiers } = this.props;\n        // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n        return !minimal && (modifiers?.arrow == null || modifiers.arrow.enabled);\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.popoverElement?.contains(element);\n    }\n\n    private isHoverInteractionKind() {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    }\n\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n    private updatePopoverState: ModifierFn = data => {\n        // always set string; let shouldComponentUpdate determine if update is necessary\n        this.setState({ transformOrigin: getTransformOrigin(data) });\n        return data;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}