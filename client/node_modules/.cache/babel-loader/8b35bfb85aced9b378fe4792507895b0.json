{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\n\nvar MultiSliderHandle = function () {\n  return null;\n};\n\nMultiSliderHandle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSliderHandle\");\n\nvar MultiSlider =\n/** @class */\nfunction (_super) {\n  __extends(MultiSlider, _super);\n\n  function MultiSlider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      labelPrecision: getLabelPrecision(_this.props),\n      tickSize: 0,\n      tickSizeRatio: 0\n    };\n    _this.handleElements = [];\n    _this.trackElement = null;\n\n    _this.addHandleRef = function (ref) {\n      if (ref != null) {\n        _this.handleElements.push(ref);\n      }\n    };\n\n    _this.maybeHandleTrackClick = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.mouseEventClientOffset(event);\n        });\n\n        if (foundHandle) {\n          foundHandle.beginHandleMovement(event);\n        }\n      }\n    };\n\n    _this.maybeHandleTrackTouch = function (event) {\n      if (_this.canHandleTrackEvent(event)) {\n        var foundHandle = _this.nearestHandleForValue(_this.handleElements, function (handle) {\n          return handle.touchEventClientOffset(event);\n        });\n\n        if (foundHandle) {\n          foundHandle.beginHandleTouchMovement(event);\n        }\n      }\n    };\n\n    _this.canHandleTrackEvent = function (event) {\n      var target = event.target; // ensure event does not come from inside the handle\n\n      return !_this.props.disabled && target.closest(\".\".concat(Classes.SLIDER_HANDLE)) == null;\n    };\n\n    _this.getHandlerForIndex = function (index, callback) {\n      return function (newValue) {\n        callback === null || callback === void 0 ? void 0 : callback(_this.getNewHandleValues(newValue, index));\n      };\n    };\n\n    _this.handleChange = function (newValues) {\n      var _a, _b;\n\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      var oldValues = handleProps.map(function (handle) {\n        return handle.value;\n      });\n\n      if (!Utils.arraysEqual(newValues, oldValues)) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n        handleProps.forEach(function (handle, index) {\n          var _a;\n\n          if (oldValues[index] !== newValues[index]) {\n            (_a = handle.onChange) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n          }\n        });\n      }\n    };\n\n    _this.handleRelease = function (newValues) {\n      var _a, _b;\n\n      var handleProps = getSortedInteractiveHandleProps(_this.props);\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, newValues);\n      handleProps.forEach(function (handle, index) {\n        var _a;\n\n        (_a = handle.onRelease) === null || _a === void 0 ? void 0 : _a.call(handle, newValues[index]);\n      });\n    };\n\n    return _this;\n  }\n\n  MultiSlider.getDerivedStateFromProps = function (props) {\n    return {\n      labelPrecision: MultiSlider.getLabelPrecision(props)\n    };\n  };\n\n  MultiSlider.getLabelPrecision = function (_a) {\n    var labelPrecision = _a.labelPrecision,\n        stepSize = _a.stepSize; // infer default label precision from stepSize because that's how much the handle moves.\n\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n  };\n\n  MultiSlider.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n    var prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n    var newHandleProps = getSortedInteractiveHandleProps(this.props);\n\n    if (newHandleProps.length !== prevHandleProps.length) {\n      // clear refs\n      this.handleElements = [];\n    }\n\n    return null;\n  };\n\n  MultiSlider.prototype.render = function () {\n    var _a;\n\n    var _this = this;\n\n    var classes = classNames(Classes.SLIDER, (_a = {}, _a[Classes.DISABLED] = this.props.disabled, _a[\"\".concat(Classes.SLIDER, \"-unlabeled\")] = this.props.labelRenderer === false, _a[Classes.VERTICAL] = this.props.vertical, _a), this.props.className);\n    return React.createElement(\"div\", {\n      className: classes,\n      onMouseDown: this.maybeHandleTrackClick,\n      onTouchStart: this.maybeHandleTrackTouch\n    }, React.createElement(\"div\", {\n      className: Classes.SLIDER_TRACK,\n      ref: function (ref) {\n        return _this.trackElement = ref;\n      }\n    }, this.renderTracks()), React.createElement(\"div\", {\n      className: Classes.SLIDER_AXIS\n    }, this.renderLabels()), this.renderHandles());\n  };\n\n  MultiSlider.prototype.componentDidMount = function () {\n    this.updateTickSize();\n  };\n\n  MultiSlider.prototype.componentDidUpdate = function (prevProps, prevState) {\n    _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n\n    this.updateTickSize();\n  };\n\n  MultiSlider.prototype.validateProps = function (props) {\n    if (props.stepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_STEP);\n    }\n\n    if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n      throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n    }\n\n    if (props.labelStepSize !== undefined && props.labelStepSize <= 0) {\n      throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n    }\n\n    var anyInvalidChildren = false;\n    React.Children.forEach(props.children, function (child) {\n      // allow boolean coercion to omit nulls and false values\n      if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n        anyInvalidChildren = true;\n      }\n    });\n\n    if (anyInvalidChildren) {\n      throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n    }\n  };\n\n  MultiSlider.prototype.formatLabel = function (value, isHandleTooltip) {\n    if (isHandleTooltip === void 0) {\n      isHandleTooltip = false;\n    }\n\n    var labelRenderer = this.props.labelRenderer;\n\n    if (labelRenderer === false) {\n      return undefined;\n    } else if (Utils.isFunction(labelRenderer)) {\n      return labelRenderer(value, {\n        isHandleTooltip: isHandleTooltip\n      });\n    } else {\n      return value.toFixed(this.state.labelPrecision);\n    }\n  };\n\n  MultiSlider.prototype.renderLabels = function () {\n    var _this = this;\n\n    if (this.props.labelRenderer === false) {\n      return null;\n    }\n\n    var values = this.getLabelValues();\n    var _a = this.props,\n        max = _a.max,\n        min = _a.min;\n    var labels = values.map(function (step, i) {\n      var offsetPercentage = formatPercentage((step - min) / (max - min));\n      var style = _this.props.vertical ? {\n        bottom: offsetPercentage\n      } : {\n        left: offsetPercentage\n      };\n      return React.createElement(\"div\", {\n        className: Classes.SLIDER_LABEL,\n        key: i,\n        style: style\n      }, _this.formatLabel(step));\n    });\n    return labels;\n  };\n\n  MultiSlider.prototype.renderTracks = function () {\n    var trackStops = getSortedHandleProps(this.props);\n    trackStops.push({\n      value: this.props.max\n    }); // render from current to previous, then increment previous\n\n    var previous = {\n      value: this.props.min\n    };\n    var handles = [];\n\n    for (var index = 0; index < trackStops.length; index++) {\n      var current = trackStops[index];\n      handles.push(this.renderTrackFill(index, previous, current));\n      previous = current;\n    }\n\n    return handles;\n  };\n\n  MultiSlider.prototype.renderTrackFill = function (index, start, end) {\n    // ensure startRatio <= endRatio\n    var _a = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(function (left, right) {\n      return left - right;\n    }),\n        startRatio = _a[0],\n        endRatio = _a[1];\n\n    var startOffset = formatPercentage(startRatio);\n    var endOffset = formatPercentage(1 - endRatio);\n    var orientationStyle = this.props.vertical ? {\n      bottom: startOffset,\n      top: endOffset,\n      left: 0\n    } : {\n      left: startOffset,\n      right: endOffset,\n      top: 0\n    };\n\n    var style = __assign(__assign({}, orientationStyle), start.trackStyleAfter || end.trackStyleBefore || {});\n\n    var classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n    return React.createElement(\"div\", {\n      key: \"track-\".concat(index),\n      className: classes,\n      style: style\n    });\n  };\n\n  MultiSlider.prototype.renderHandles = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        max = _a.max,\n        min = _a.min,\n        stepSize = _a.stepSize,\n        vertical = _a.vertical;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n\n    if (handleProps.length === 0) {\n      return null;\n    }\n\n    return handleProps.map(function (_a, index) {\n      var _b;\n\n      var value = _a.value,\n          type = _a.type,\n          className = _a.className;\n      return React.createElement(Handle, {\n        className: classNames((_b = {}, _b[Classes.START] = type === HandleType.START, _b[Classes.END] = type === HandleType.END, _b), className),\n        disabled: disabled,\n        key: \"\".concat(index, \"-\").concat(handleProps.length),\n        label: _this.formatLabel(value, true),\n        max: max,\n        min: min,\n        onChange: _this.getHandlerForIndex(index, _this.handleChange),\n        onRelease: _this.getHandlerForIndex(index, _this.handleRelease),\n        ref: _this.addHandleRef,\n        stepSize: stepSize,\n        tickSize: _this.state.tickSize,\n        tickSizeRatio: _this.state.tickSizeRatio,\n        value: value,\n        vertical: vertical\n      });\n    });\n  };\n\n  MultiSlider.prototype.nearestHandleForValue = function (handles, getOffset) {\n    return argMin(handles, function (handle) {\n      var offset = getOffset(handle);\n      var offsetValue = handle.clientToValue(offset);\n      var handleValue = handle.props.value;\n      return Math.abs(offsetValue - handleValue);\n    });\n  };\n\n  MultiSlider.prototype.getNewHandleValues = function (newValue, oldIndex) {\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n    var oldValues = handleProps.map(function (handle) {\n      return handle.value;\n    });\n    var newValues = oldValues.slice();\n    newValues[oldIndex] = newValue;\n    newValues.sort(function (left, right) {\n      return left - right;\n    });\n    var newIndex = newValues.indexOf(newValue);\n    var lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n\n    if (lockIndex === -1) {\n      fillValues(newValues, oldIndex, newIndex, newValue);\n    } else {\n      // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n      var lockValue = oldValues[lockIndex];\n      fillValues(oldValues, oldIndex, lockIndex, lockValue);\n      return oldValues;\n    }\n\n    return newValues;\n  };\n\n  MultiSlider.prototype.findFirstLockedHandleIndex = function (startIndex, endIndex) {\n    var inc = startIndex < endIndex ? 1 : -1;\n    var handleProps = getSortedInteractiveHandleProps(this.props);\n\n    for (var index = startIndex + inc; index !== endIndex + inc; index += inc) {\n      if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n        return index;\n      }\n    }\n\n    return -1;\n  };\n\n  MultiSlider.prototype.getLabelValues = function () {\n    var _a = this.props,\n        labelStepSize = _a.labelStepSize,\n        labelValues = _a.labelValues,\n        min = _a.min,\n        max = _a.max;\n    var values = [];\n\n    if (labelValues !== undefined) {\n      values = labelValues.slice();\n    } else {\n      for (var i = min; i < max || Utils.approxEqual(i, max); i += labelStepSize !== null && labelStepSize !== void 0 ? labelStepSize : 1) {\n        values.push(i);\n      }\n    }\n\n    return values;\n  };\n\n  MultiSlider.prototype.getOffsetRatio = function (value) {\n    return Utils.clamp((value - this.props.min) * this.state.tickSizeRatio, 0, 1);\n  };\n\n  MultiSlider.prototype.getTrackIntent = function (start, end) {\n    if (!this.props.showTrackFill) {\n      return Intent.NONE;\n    }\n\n    if (start.intentAfter !== undefined) {\n      return start.intentAfter;\n    } else if (end !== undefined && end.intentBefore !== undefined) {\n      return end.intentBefore;\n    }\n\n    return this.props.defaultTrackIntent;\n  };\n\n  MultiSlider.prototype.updateTickSize = function () {\n    if (this.trackElement != null) {\n      var trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n      var tickSizeRatio = 1 / (this.props.max - this.props.min);\n      var tickSize = trackSize * tickSizeRatio;\n      this.setState({\n        tickSize: tickSize,\n        tickSizeRatio: tickSizeRatio\n      });\n    }\n  };\n\n  MultiSlider.defaultSliderProps = {\n    disabled: false,\n    max: 10,\n    min: 0,\n    showTrackFill: true,\n    stepSize: 1,\n    vertical: false\n  };\n  MultiSlider.defaultProps = __assign(__assign({}, MultiSlider.defaultSliderProps), {\n    defaultTrackIntent: Intent.NONE\n  });\n  MultiSlider.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".MultiSlider\");\n  MultiSlider.Handle = MultiSliderHandle;\n  return MultiSlider;\n}(AbstractPureComponent2);\n\nexport { MultiSlider };\n\nfunction getLabelPrecision(_a) {\n  var labelPrecision = _a.labelPrecision,\n      _b = _a.stepSize,\n      stepSize = _b === void 0 ? MultiSlider.defaultSliderProps.stepSize : _b; // infer default label precision from stepSize because that's how much the handle moves.\n\n  return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props) {\n  return getSortedHandleProps(props, function (childProps) {\n    return childProps.interactionKind !== HandleInteractionKind.NONE;\n  });\n}\n\nfunction getSortedHandleProps(_a, predicate) {\n  var children = _a.children;\n\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n\n  var maybeHandles = React.Children.map(children, function (child) {\n    return Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null;\n  });\n  var handles = maybeHandles != null ? maybeHandles : [];\n  handles = handles.filter(function (handle) {\n    return handle !== null;\n  });\n  handles.sort(function (left, right) {\n    return left.value - right.value;\n  });\n  return handles;\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Intent","Errors","DISPLAYNAME_PREFIX","Utils","Handle","HandleInteractionKind","HandleType","argMin","fillValues","formatPercentage","MultiSliderHandle","displayName","__extends","_this","labelPrecision","getLabelPrecision","props","tickSize","tickSizeRatio","ref","handleElements","push","event","canHandleTrackEvent","foundHandle","nearestHandleForValue","mouseEventClientOffset","beginHandleMovement","touchEventClientOffset","beginHandleTouchMovement","target","disabled","closest","SLIDER_HANDLE","index","callback","newValue","getNewHandleValues","newValues","handleProps","getSortedInteractiveHandleProps","oldValues","map","value","arraysEqual","onChange","_b","forEach","handle","_a","onRelease","MultiSlider","stepSize","countDecimalPlaces","prevProps","prevHandleProps","newHandleProps","length","classes","SLIDER","DISABLED","labelRenderer","VERTICAL","vertical","className","onMouseDown","maybeHandleTrackClick","onTouchStart","maybeHandleTrackTouch","SLIDER_TRACK","trackElement","renderTracks","SLIDER_AXIS","renderLabels","renderHandles","updateTickSize","prevState","_super","componentDidUpdate","call","Error","SLIDER_ZERO_STEP","labelStepSize","undefined","labelValues","MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX","SLIDER_ZERO_LABEL_STEP","anyInvalidChildren","Children","children","child","isElementOfType","MULTISLIDER_INVALID_CHILD","isHandleTooltip","isFunction","toFixed","state","values","getLabelValues","max","min","labels","step","i","offsetPercentage","style","bottom","left","SLIDER_LABEL","key","formatLabel","trackStops","getSortedHandleProps","previous","handles","current","renderTrackFill","start","end","getOffsetRatio","sort","right","startRatio","endRatio","startOffset","endOffset","orientationStyle","top","trackStyleAfter","trackStyleBefore","SLIDER_PROGRESS","intentClass","getTrackIntent","type","START","END","concat","label","getHandlerForIndex","handleChange","handleRelease","addHandleRef","getOffset","offset","offsetValue","clientToValue","handleValue","Math","abs","oldIndex","slice","newIndex","indexOf","lockIndex","findFirstLockedHandleIndex","lockValue","startIndex","endIndex","inc","interactionKind","PUSH","approxEqual","clamp","showTrackFill","NONE","intentAfter","intentBefore","defaultTrackIntent","trackSize","clientHeight","clientWidth","setState","__assign","defaultSliderProps","predicate","maybeHandles","filter"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/components/slider/multiSlider.tsx"],"sourcesContent":["/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Intent } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Handle } from \"./handle\";\nimport { HandleInteractionKind, HandleProps, HandleType } from \"./handleProps\";\nimport { argMin, fillValues, formatPercentage } from \"./sliderUtils\";\n\n/**\n * SFC used to pass slider handle props to a `MultiSlider`.\n * This element is not rendered directly.\n */\nconst MultiSliderHandle: React.FC<HandleProps> = () => null;\nMultiSliderHandle.displayName = `${DISPLAYNAME_PREFIX}.MultiSliderHandle`;\n\nexport interface ISliderBaseProps extends Props, IntentProps {\n    children?: React.ReactNode;\n\n    /**\n     * Whether the slider is non-interactive.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Increment between successive labels. Must be greater than zero.\n     *\n     * @default inferred (if labelStepSize is undefined)\n     */\n    labelStepSize?: number;\n\n    /**\n     * Array of specific values for the label placement. This prop is mutually exclusive with\n     * `labelStepSize`.\n     */\n    labelValues?: readonly number[];\n\n    /**\n     * Number of decimal places to use when rendering label value. Default value is the number of\n     * decimals used in the `stepSize` prop. This prop has _no effect_ if you supply a custom\n     * `labelRenderer` callback.\n     *\n     * @default inferred from stepSize\n     */\n    labelPrecision?: number;\n\n    /**\n     * Maximum value of the slider.\n     *\n     * @default 10\n     */\n    max?: number;\n\n    /**\n     * Minimum value of the slider.\n     *\n     * @default 0\n     */\n    min?: number;\n\n    /**\n     * Whether a solid bar should be rendered on the track between current and initial values,\n     * or between handles for `RangeSlider`.\n     *\n     * @default true\n     */\n    showTrackFill?: boolean;\n\n    /**\n     * Increment between successive values; amount by which the handle moves. Must be greater than zero.\n     *\n     * @default 1\n     */\n    stepSize?: number;\n\n    /**\n     * Callback to render a single label. Useful for formatting numbers as currency or percentages.\n     * If `true`, labels will use number value formatted to `labelPrecision` decimal places.\n     * If `false`, labels will not be shown.\n     *\n     * The callback is provided a numeric value and optional rendering options, which include:\n     * - isHandleTooltip: whether this label is being rendered within a handle tooltip\n     *\n     * @default true\n     */\n    labelRenderer?: boolean | ((value: number, opts?: { isHandleTooltip: boolean }) => string | JSX.Element);\n\n    /**\n     * Whether to show the slider in a vertical orientation.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type MultiSliderProps = IMultiSliderProps;\n/** @deprecated use MultiSliderProps */\nexport interface IMultiSliderProps extends ISliderBaseProps {\n    /** Default intent of a track segment, used only if no handle specifies `intentBefore/After`. */\n    defaultTrackIntent?: Intent;\n\n    /** Callback invoked when a handle value changes. Receives handle values in sorted order. */\n    onChange?(values: number[]): void;\n\n    /** Callback invoked when a handle is released. Receives handle values in sorted order. */\n    onRelease?(values: number[]): void;\n}\n\nexport interface ISliderState {\n    labelPrecision: number;\n    /** the client size, in pixels, of one tick */\n    tickSize: number;\n    /** the size of one tick as a ratio of the component's client size */\n    tickSizeRatio: number;\n}\n\nexport class MultiSlider extends AbstractPureComponent2<MultiSliderProps, ISliderState> {\n    public static defaultSliderProps: ISliderBaseProps = {\n        disabled: false,\n        max: 10,\n        min: 0,\n        showTrackFill: true,\n        stepSize: 1,\n        vertical: false,\n    };\n\n    public static defaultProps: MultiSliderProps = {\n        ...MultiSlider.defaultSliderProps,\n        defaultTrackIntent: Intent.NONE,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSlider`;\n\n    public static Handle = MultiSliderHandle;\n\n    public static getDerivedStateFromProps(props: MultiSliderProps) {\n        return { labelPrecision: MultiSlider.getLabelPrecision(props) };\n    }\n\n    private static getLabelPrecision({ labelPrecision, stepSize }: MultiSliderProps) {\n        // infer default label precision from stepSize because that's how much the handle moves.\n        return labelPrecision == null ? Utils.countDecimalPlaces(stepSize!) : labelPrecision;\n    }\n\n    public state: ISliderState = {\n        labelPrecision: getLabelPrecision(this.props),\n        tickSize: 0,\n        tickSizeRatio: 0,\n    };\n\n    private handleElements: Handle[] = [];\n\n    private trackElement: HTMLElement | null = null;\n\n    public getSnapshotBeforeUpdate(prevProps: MultiSliderProps): null {\n        const prevHandleProps = getSortedInteractiveHandleProps(prevProps);\n        const newHandleProps = getSortedInteractiveHandleProps(this.props);\n        if (newHandleProps.length !== prevHandleProps.length) {\n            // clear refs\n            this.handleElements = [];\n        }\n        return null;\n    }\n\n    public render() {\n        const classes = classNames(\n            Classes.SLIDER,\n            {\n                [Classes.DISABLED]: this.props.disabled,\n                [`${Classes.SLIDER}-unlabeled`]: this.props.labelRenderer === false,\n                [Classes.VERTICAL]: this.props.vertical,\n            },\n            this.props.className,\n        );\n        return (\n            <div className={classes} onMouseDown={this.maybeHandleTrackClick} onTouchStart={this.maybeHandleTrackTouch}>\n                <div className={Classes.SLIDER_TRACK} ref={ref => (this.trackElement = ref)}>\n                    {this.renderTracks()}\n                </div>\n                <div className={Classes.SLIDER_AXIS}>{this.renderLabels()}</div>\n                {this.renderHandles()}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateTickSize();\n    }\n\n    public componentDidUpdate(prevProps: MultiSliderProps, prevState: ISliderState) {\n        super.componentDidUpdate(prevProps, prevState);\n        this.updateTickSize();\n    }\n\n    protected validateProps(props: React.PropsWithChildren<MultiSliderProps>) {\n        if (props.stepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_STEP);\n        }\n        if (props.labelStepSize !== undefined && props.labelValues !== undefined) {\n            throw new Error(Errors.MULTISLIDER_WARN_LABEL_STEP_SIZE_LABEL_VALUES_MUTEX);\n        }\n        if (props.labelStepSize !== undefined && props.labelStepSize! <= 0) {\n            throw new Error(Errors.SLIDER_ZERO_LABEL_STEP);\n        }\n\n        let anyInvalidChildren = false;\n        React.Children.forEach(props.children, child => {\n            // allow boolean coercion to omit nulls and false values\n            if (child && !Utils.isElementOfType(child, MultiSlider.Handle)) {\n                anyInvalidChildren = true;\n            }\n        });\n        if (anyInvalidChildren) {\n            throw new Error(Errors.MULTISLIDER_INVALID_CHILD);\n        }\n    }\n\n    private formatLabel(value: number, isHandleTooltip: boolean = false) {\n        const { labelRenderer } = this.props;\n        if (labelRenderer === false) {\n            return undefined;\n        } else if (Utils.isFunction(labelRenderer)) {\n            return labelRenderer(value, { isHandleTooltip });\n        } else {\n            return value.toFixed(this.state.labelPrecision);\n        }\n    }\n\n    private renderLabels() {\n        if (this.props.labelRenderer === false) {\n            return null;\n        }\n\n        const values = this.getLabelValues();\n        const { max, min } = this.props;\n        const labels = values.map((step, i) => {\n            const offsetPercentage = formatPercentage((step - min!) / (max! - min!));\n            const style = this.props.vertical ? { bottom: offsetPercentage } : { left: offsetPercentage };\n            return (\n                <div className={Classes.SLIDER_LABEL} key={i} style={style}>\n                    {this.formatLabel(step)}\n                </div>\n            );\n        });\n\n        return labels;\n    }\n\n    private renderTracks() {\n        const trackStops = getSortedHandleProps(this.props);\n        trackStops.push({ value: this.props.max! });\n\n        // render from current to previous, then increment previous\n        let previous: HandleProps = { value: this.props.min! };\n        const handles: JSX.Element[] = [];\n        for (let index = 0; index < trackStops.length; index++) {\n            const current = trackStops[index];\n            handles.push(this.renderTrackFill(index, previous, current));\n            previous = current;\n        }\n        return handles;\n    }\n\n    private renderTrackFill(index: number, start: HandleProps, end: HandleProps) {\n        // ensure startRatio <= endRatio\n        const [startRatio, endRatio] = [this.getOffsetRatio(start.value), this.getOffsetRatio(end.value)].sort(\n            (left, right) => left - right,\n        );\n        const startOffset = formatPercentage(startRatio);\n        const endOffset = formatPercentage(1 - endRatio);\n        const orientationStyle: React.CSSProperties = this.props.vertical\n            ? { bottom: startOffset, top: endOffset, left: 0 }\n            : { left: startOffset, right: endOffset, top: 0 };\n\n        const style: React.CSSProperties = {\n            ...orientationStyle,\n            ...(start.trackStyleAfter || end.trackStyleBefore || {}),\n        };\n\n        const classes = classNames(Classes.SLIDER_PROGRESS, Classes.intentClass(this.getTrackIntent(start, end)));\n        return <div key={`track-${index}`} className={classes} style={style} />;\n    }\n\n    private renderHandles() {\n        const { disabled, max, min, stepSize, vertical } = this.props;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        if (handleProps.length === 0) {\n            return null;\n        }\n\n        return handleProps.map(({ value, type, className }, index) => (\n            <Handle\n                className={classNames(\n                    {\n                        [Classes.START]: type === HandleType.START,\n                        [Classes.END]: type === HandleType.END,\n                    },\n                    className,\n                )}\n                disabled={disabled}\n                key={`${index}-${handleProps.length}`}\n                label={this.formatLabel(value, true)}\n                max={max!}\n                min={min!}\n                onChange={this.getHandlerForIndex(index, this.handleChange)}\n                onRelease={this.getHandlerForIndex(index, this.handleRelease)}\n                ref={this.addHandleRef}\n                stepSize={stepSize!}\n                tickSize={this.state.tickSize}\n                tickSizeRatio={this.state.tickSizeRatio}\n                value={value}\n                vertical={vertical!}\n            />\n        ));\n    }\n\n    private addHandleRef = (ref: Handle) => {\n        if (ref != null) {\n            this.handleElements.push(ref);\n        }\n    };\n\n    private maybeHandleTrackClick = (event: React.MouseEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.mouseEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleMovement(event);\n            }\n        }\n    };\n\n    private maybeHandleTrackTouch = (event: React.TouchEvent<HTMLDivElement>) => {\n        if (this.canHandleTrackEvent(event)) {\n            const foundHandle = this.nearestHandleForValue(this.handleElements, handle =>\n                handle.touchEventClientOffset(event),\n            );\n            if (foundHandle) {\n                foundHandle.beginHandleTouchMovement(event);\n            }\n        }\n    };\n\n    private canHandleTrackEvent = (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => {\n        const target = event.target as HTMLElement;\n        // ensure event does not come from inside the handle\n        return !this.props.disabled && target.closest(`.${Classes.SLIDER_HANDLE}`) == null;\n    };\n\n    private nearestHandleForValue(handles: Handle[], getOffset: (handle: Handle) => number): Handle | undefined {\n        return argMin(handles, handle => {\n            const offset = getOffset(handle);\n            const offsetValue = handle.clientToValue(offset);\n            const handleValue = handle.props.value!;\n            return Math.abs(offsetValue - handleValue);\n        });\n    }\n\n    private getHandlerForIndex = (index: number, callback?: (values: number[]) => void) => {\n        return (newValue: number) => {\n            callback?.(this.getNewHandleValues(newValue, index));\n        };\n    };\n\n    private getNewHandleValues(newValue: number, oldIndex: number) {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        const newValues = oldValues.slice();\n        newValues[oldIndex] = newValue;\n        newValues.sort((left, right) => left - right);\n\n        const newIndex = newValues.indexOf(newValue);\n        const lockIndex = this.findFirstLockedHandleIndex(oldIndex, newIndex);\n        if (lockIndex === -1) {\n            fillValues(newValues, oldIndex, newIndex, newValue);\n        } else {\n            // If pushing past a locked handle, discard the new value and only make the updates to clamp values against the lock.\n            const lockValue = oldValues[lockIndex];\n            fillValues(oldValues, oldIndex, lockIndex, lockValue);\n            return oldValues;\n        }\n\n        return newValues;\n    }\n\n    private findFirstLockedHandleIndex(startIndex: number, endIndex: number): number {\n        const inc = startIndex < endIndex ? 1 : -1;\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n\n        for (let index = startIndex + inc; index !== endIndex + inc; index += inc) {\n            if (handleProps[index].interactionKind !== HandleInteractionKind.PUSH) {\n                return index;\n            }\n        }\n\n        return -1;\n    }\n\n    private handleChange = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        const oldValues = handleProps.map(handle => handle.value);\n        if (!Utils.arraysEqual(newValues, oldValues)) {\n            this.props.onChange?.(newValues);\n            handleProps.forEach((handle, index) => {\n                if (oldValues[index] !== newValues[index]) {\n                    handle.onChange?.(newValues[index]);\n                }\n            });\n        }\n    };\n\n    private handleRelease = (newValues: number[]) => {\n        const handleProps = getSortedInteractiveHandleProps(this.props);\n        this.props.onRelease?.(newValues);\n        handleProps.forEach((handle, index) => {\n            handle.onRelease?.(newValues[index]);\n        });\n    };\n\n    private getLabelValues() {\n        const { labelStepSize, labelValues, min, max } = this.props;\n        let values: number[] = [];\n        if (labelValues !== undefined) {\n            values = labelValues.slice();\n        } else {\n            for (let i = min!; i < max! || Utils.approxEqual(i, max!); i += labelStepSize ?? 1) {\n                values.push(i);\n            }\n        }\n\n        return values;\n    }\n\n    private getOffsetRatio(value: number) {\n        return Utils.clamp((value - this.props.min!) * this.state.tickSizeRatio, 0, 1);\n    }\n\n    private getTrackIntent(start: HandleProps, end?: HandleProps): Intent {\n        if (!this.props.showTrackFill) {\n            return Intent.NONE;\n        }\n        if (start.intentAfter !== undefined) {\n            return start.intentAfter;\n        } else if (end !== undefined && end.intentBefore !== undefined) {\n            return end.intentBefore;\n        }\n        return this.props.defaultTrackIntent!;\n    }\n\n    private updateTickSize() {\n        if (this.trackElement != null) {\n            const trackSize = this.props.vertical ? this.trackElement.clientHeight : this.trackElement.clientWidth;\n            const tickSizeRatio = 1 / ((this.props.max as number) - (this.props.min as number));\n            const tickSize = trackSize * tickSizeRatio;\n            this.setState({ tickSize, tickSizeRatio });\n        }\n    }\n}\n\nfunction getLabelPrecision({ labelPrecision, stepSize = MultiSlider.defaultSliderProps.stepSize! }: MultiSliderProps) {\n    // infer default label precision from stepSize because that's how much the handle moves.\n    return labelPrecision == null ? Utils.countDecimalPlaces(stepSize) : labelPrecision;\n}\n\nfunction getSortedInteractiveHandleProps(props: React.PropsWithChildren<MultiSliderProps>): HandleProps[] {\n    return getSortedHandleProps(props, childProps => childProps.interactionKind !== HandleInteractionKind.NONE);\n}\n\nfunction getSortedHandleProps({ children }: MultiSliderProps, predicate: (props: HandleProps) => boolean = () => true) {\n    const maybeHandles = React.Children.map(children, child =>\n        Utils.isElementOfType(child, MultiSlider.Handle) && predicate(child.props) ? child.props : null,\n    );\n    let handles = maybeHandles != null ? maybeHandles : [];\n    handles = handles.filter(handle => handle !== null);\n    handles.sort((left, right) => left.value - right.value);\n    return handles;\n}\n"]},"metadata":{},"sourceType":"module"}