{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __spreadArray } from \"tslib\";\nimport * as React from \"react\";\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\n\nexport function useHotkeys(keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.document,\n      document = _a === void 0 ? getDefaultDocument() : _a,\n      _b = options.showDialogKeyCombo,\n      showDialogKeyCombo = _b === void 0 ? \"?\" : _b;\n  var localKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return !k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]);\n  var globalKeys = React.useMemo(function () {\n    return keys.filter(function (k) {\n      return k.global;\n    }).map(function (k) {\n      return {\n        combo: parseKeyCombo(k.combo),\n        config: k\n      };\n    });\n  }, [keys]); // register keys with global context\n\n  var _c = React.useContext(HotkeysContext),\n      state = _c[0],\n      dispatch = _c[1];\n\n  if (!state.hasProvider) {\n    React.useEffect(function () {\n      return console.warn(HOTKEYS_PROVIDER_NOT_FOUND);\n    }, []);\n  } // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n\n\n  React.useEffect(function () {\n    var payload = __spreadArray(__spreadArray([], globalKeys.map(function (k) {\n      return k.config;\n    }), true), localKeys.map(function (k) {\n      return k.config;\n    }), true);\n\n    dispatch({\n      type: \"ADD_HOTKEYS\",\n      payload: payload\n    });\n    return function () {\n      return dispatch({\n        type: \"REMOVE_HOTKEYS\",\n        payload: payload\n      });\n    };\n  }, [keys]);\n\n  var invokeNamedCallbackIfComboRecognized = function (global, combo, callbackName, e) {\n    var _a, _b;\n\n    var isTextInput = isTargetATextInput(e);\n\n    for (var _i = 0, _c = global ? globalKeys : localKeys; _i < _c.length; _i++) {\n      var key = _c[_i];\n      var _d = key.config,\n          _e = _d.allowInInput,\n          allowInInput = _e === void 0 ? false : _e,\n          _f = _d.disabled,\n          disabled = _f === void 0 ? false : _f,\n          _g = _d.preventDefault,\n          preventDefault = _g === void 0 ? false : _g,\n          _h = _d.stopPropagation,\n          stopPropagation = _h === void 0 ? false : _h;\n      var shouldIgnore = isTextInput && !allowInInput || disabled;\n\n      if (!shouldIgnore && comboMatches(key.combo, combo)) {\n        if (preventDefault) {\n          e.preventDefault();\n        }\n\n        if (stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n\n        (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n\n  var handleGlobalKeyDown = React.useCallback(function (e) {\n    // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n    var combo = getKeyCombo(e);\n    var isTextInput = isTargetATextInput(e);\n\n    if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n      dispatch({\n        type: \"OPEN_DIALOG\"\n      });\n    } else {\n      invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n    }\n  }, [globalKeys]);\n  var handleGlobalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e);\n  }, [globalKeys]);\n  var handleLocalKeyDown = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent);\n  }, [localKeys]);\n  var handleLocalKeyUp = React.useCallback(function (e) {\n    return invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent);\n  }, [localKeys]);\n  React.useEffect(function () {\n    // document is guaranteed to be defined inside effects\n    document.addEventListener(\"keydown\", handleGlobalKeyDown);\n    document.addEventListener(\"keyup\", handleGlobalKeyUp);\n    return function () {\n      document.removeEventListener(\"keydown\", handleGlobalKeyDown);\n      document.removeEventListener(\"keyup\", handleGlobalKeyUp);\n    };\n  }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n  return {\n    handleKeyDown: handleLocalKeyDown,\n    handleKeyUp: handleLocalKeyUp\n  };\n}\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\n\nfunction isTargetATextInput(e) {\n  var elem = e.target; // we check these cases for unit testing, but this should not happen\n  // during normal operation\n\n  if (elem == null || elem.closest == null) {\n    return false;\n  }\n\n  var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n  if (editable == null) {\n    return false;\n  } // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n\n\n  if (editable.tagName.toLowerCase() === \"input\") {\n    var inputType = editable.type;\n\n    if (inputType === \"checkbox\" || inputType === \"radio\") {\n      return false;\n    }\n  } // don't let read-only fields prevent hotkey behavior\n\n\n  if (editable.readOnly) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getDefaultDocument() {\n  if (typeof window === \"undefined\") {\n    return undefined;\n  }\n\n  return window.document;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,0BAAT,QAA2C,qBAA3C;AACA,SAASC,YAAT,EAAuBC,WAAvB,EAA+CC,aAA/C,QAAoE,uCAApE;AACA,SAASC,cAAT,QAA+B,eAA/B;AAyBA;;;;;;;AAMA,OAAM,SAAUC,UAAV,CAAqBC,IAArB,EAAoDC,OAApD,EAAmF;EAA/B;IAAAA;EAA+B;;EAC7E,SAA8DA,OAAO,SAArE;EAAA,YAAQ,mBAAGC,kBAAkB,EAArB,GAAuBC,EAA/B;EAAA,IAAiCC,KAA6BH,OAAO,mBAArE;EAAA,IAAiCI,kBAAkB,mBAAG,GAAH,GAAMD,EAAzD;EACR,IAAME,SAAS,GAAGb,KAAK,CAACc,OAAN,CACd;IACI,WAAI,CACCC,MADL,CACY,aAAC;MAAI,QAACC,CAAC,CAACC,MAAH;IAAS,CAD1B,EAEKC,GAFL,CAES,aAAC;MAAI,OAAC;QACPC,KAAK,EAAEf,aAAa,CAACY,CAAC,CAACG,KAAH,CADb;QAEPC,MAAM,EAAEJ;MAFD,CAAD;IAGR,CALN;EAKO,CAPG,EAQd,CAACT,IAAD,CARc,CAAlB;EAUA,IAAMc,UAAU,GAAGrB,KAAK,CAACc,OAAN,CACf;IACI,WAAI,CACCC,MADL,CACY,aAAC;MAAI,QAAC,CAACE,MAAF;IAAQ,CADzB,EAEKC,GAFL,CAES,aAAC;MAAI,OAAC;QACPC,KAAK,EAAEf,aAAa,CAACY,CAAC,CAACG,KAAH,CADb;QAEPC,MAAM,EAAEJ;MAFD,CAAD;IAGR,CALN;EAKO,CAPI,EAQf,CAACT,IAAD,CARe,CAAnB,CAZqF,CAuBrF;;EACM,SAAoBP,KAAK,CAACsB,UAAN,CAAiBjB,cAAjB,CAApB;EAAA,IAACkB,KAAK,QAAN;EAAA,IAAQC,QAAQ,QAAhB;;EAEN,IAAI,CAACD,KAAK,CAACE,WAAX,EAAwB;IACpBzB,KAAK,CAAC0B,SAAN,CAAgB;MAAM,cAAO,CAACC,IAAR,CAAa1B,0BAAb;IAAwC,CAA9D,EAAgE,EAAhE;EACH,CA5BoF,CA8BrF;;;EACAD,KAAK,CAAC0B,SAAN,CAAgB;IACZ,IAAME,OAAO,mCAAOP,UAAU,CAACH,GAAX,CAAe,aAAC;MAAI,QAAC,CAACE,MAAF;IAAQ,CAA5B,CAAP,EAAoC,IAApC,GAAyCP,SAAS,CAACK,GAAV,CAAc,aAAC;MAAI,QAAC,CAACE,MAAF;IAAQ,CAA3B,CAAzC,EAAqE,IAArE,CAAb;;IACAI,QAAQ,CAAC;MAAEK,IAAI,EAAE,aAAR;MAAuBD,OAAO;IAA9B,CAAD,CAAR;IACA,OAAO;MAAM,eAAQ,CAAC;QAAEC,IAAI,EAAE,gBAAR;QAA0BD,OAAO;MAAjC,CAAD,CAAR;IAA6C,CAA1D;EACH,CAJD,EAIG,CAACrB,IAAD,CAJH;;EAMA,IAAMuB,oCAAoC,GAAG,UACzCb,MADyC,EAEzCE,KAFyC,EAGzCY,YAHyC,EAIzCC,CAJyC,EAIzB;;;IAEhB,IAAMC,WAAW,GAAGC,kBAAkB,CAACF,CAAD,CAAtC;;IACA,KAAkB,uBAAM,GAAGX,UAAH,GAAgBR,SAAxC,EAAkBsB,cAAlB,EAAkBA,IAAlB,EAAmD;MAA9C,IAAMC,GAAG,SAAT;MACK,SAKFA,GAAG,CAAChB,MALF;MAAA,IACFiB,oBADE;MAAA,IACFC,YAAY,mBAAG,KAAH,GAAQD,EADlB;MAAA,IAEFE,gBAFE;MAAA,IAEFC,QAAQ,mBAAG,KAAH,GAAQD,EAFd;MAAA,IAGFE,sBAHE;MAAA,IAGFC,cAAc,mBAAG,KAAH,GAAQD,EAHpB;MAAA,IAIFE,uBAJE;MAAA,IAIFC,eAAe,mBAAG,KAAH,GAAQD,EAJrB;MAMN,IAAME,YAAY,GAAIZ,WAAW,IAAI,CAACK,YAAjB,IAAkCE,QAAvD;;MACA,IAAI,CAACK,YAAD,IAAiB3C,YAAY,CAACkC,GAAG,CAACjB,KAAL,EAAYA,KAAZ,CAAjC,EAAqD;QACjD,IAAIuB,cAAJ,EAAoB;UAChBV,CAAC,CAACU,cAAF;QACH;;QACD,IAAIE,eAAJ,EAAqB;UACjB;UACCZ,CAAS,CAACc,oBAAV,GAAiC,IAAjC;UACDd,CAAC,CAACY,eAAF;QACH;;QACD,eAAG,CAACxB,MAAJ,EAAWW,YAAX,OAAwB,IAAxB,IAAwBpB,aAAxB,GAAwB,MAAxB,GAAwBA,YAAGqB,CAAH,CAAxB;MACH;IACJ;EACJ,CA3BD;;EA6BA,IAAMe,mBAAmB,GAAG/C,KAAK,CAACgD,WAAN,CACxB,UAAChB,CAAD,EAAiB;IACb;IACA,IAAMb,KAAK,GAAGhB,WAAW,CAAC6B,CAAD,CAAzB;IACA,IAAMC,WAAW,GAAGC,kBAAkB,CAACF,CAAD,CAAtC;;IACA,IAAI,CAACC,WAAD,IAAgB/B,YAAY,CAACE,aAAa,CAACQ,kBAAD,CAAd,EAAoCO,KAApC,CAAhC,EAA4E;MACxEK,QAAQ,CAAC;QAAEK,IAAI,EAAE;MAAR,CAAD,CAAR;IACH,CAFD,MAEO;MACHC,oCAAoC,CAAC,IAAD,EAAO3B,WAAW,CAAC6B,CAAD,CAAlB,EAAuB,WAAvB,EAAoCA,CAApC,CAApC;IACH;EACJ,CAVuB,EAWxB,CAACX,UAAD,CAXwB,CAA5B;EAaA,IAAM4B,iBAAiB,GAAGjD,KAAK,CAACgD,WAAN,CACtB,UAAChB,CAAD,EAAiB;IAAK,2CAAoC,CAAC,IAAD,EAAO7B,WAAW,CAAC6B,CAAD,CAAlB,EAAuB,SAAvB,EAAkCA,CAAlC,CAApC;EAAwE,CADxE,EAEtB,CAACX,UAAD,CAFsB,CAA1B;EAKA,IAAM6B,kBAAkB,GAAGlD,KAAK,CAACgD,WAAN,CACvB,UAAChB,CAAD,EAAoC;IAChC,2CAAoC,CAAC,KAAD,EAAQ7B,WAAW,CAAC6B,CAAC,CAACmB,WAAH,CAAnB,EAAoC,WAApC,EAAiDnB,CAAC,CAACmB,WAAnD,CAApC;EAAmG,CAFhF,EAGvB,CAACtC,SAAD,CAHuB,CAA3B;EAKA,IAAMuC,gBAAgB,GAAGpD,KAAK,CAACgD,WAAN,CACrB,UAAChB,CAAD,EAAoC;IAChC,2CAAoC,CAAC,KAAD,EAAQ7B,WAAW,CAAC6B,CAAC,CAACmB,WAAH,CAAnB,EAAoC,SAApC,EAA+CnB,CAAC,CAACmB,WAAjD,CAApC;EAAiG,CAFhF,EAGrB,CAACtC,SAAD,CAHqB,CAAzB;EAMAb,KAAK,CAAC0B,SAAN,CAAgB;IACZ;IACA2B,QAAS,CAACC,gBAAV,CAA2B,SAA3B,EAAsCP,mBAAtC;IACAM,QAAS,CAACC,gBAAV,CAA2B,OAA3B,EAAoCL,iBAApC;IACA,OAAO;MACHI,QAAS,CAACE,mBAAV,CAA8B,SAA9B,EAAyCR,mBAAzC;MACAM,QAAS,CAACE,mBAAV,CAA8B,OAA9B,EAAuCN,iBAAvC;IACH,CAHD;EAIH,CARD,EAQG,CAACF,mBAAD,EAAsBE,iBAAtB,CARH;EAUA,OAAO;IAAEO,aAAa,EAAEN,kBAAjB;IAAqCO,WAAW,EAAEL;EAAlD,CAAP;AACH;AAED;;;;AAGA,SAASlB,kBAAT,CAA4BF,CAA5B,EAA4C;EACxC,IAAM0B,IAAI,GAAG1B,CAAC,CAAC2B,MAAf,CADwC,CAExC;EACA;;EACA,IAAID,IAAI,IAAI,IAAR,IAAgBA,IAAI,CAACE,OAAL,IAAgB,IAApC,EAA0C;IACtC,OAAO,KAAP;EACH;;EAED,IAAMC,QAAQ,GAAGH,IAAI,CAACE,OAAL,CAAa,yCAAb,CAAjB;;EAEA,IAAIC,QAAQ,IAAI,IAAhB,EAAsB;IAClB,OAAO,KAAP;EACH,CAZuC,CAcxC;;;EACA,IAAIA,QAAQ,CAACC,OAAT,CAAiBC,WAAjB,OAAmC,OAAvC,EAAgD;IAC5C,IAAMC,SAAS,GAAIH,QAA6B,CAAChC,IAAjD;;IACA,IAAImC,SAAS,KAAK,UAAd,IAA4BA,SAAS,KAAK,OAA9C,EAAuD;MACnD,OAAO,KAAP;IACH;EACJ,CApBuC,CAsBxC;;;EACA,IAAKH,QAA6B,CAACI,QAAnC,EAA6C;IACzC,OAAO,KAAP;EACH;;EAED,OAAO,IAAP;AACH;;AAED,SAASxD,kBAAT,GAA2B;EACvB,IAAI,OAAOyD,MAAP,KAAkB,WAAtB,EAAmC;IAC/B,OAAOC,SAAP;EACH;;EACD,OAAOD,MAAM,CAACb,QAAd;AACH","names":["React","HOTKEYS_PROVIDER_NOT_FOUND","comboMatches","getKeyCombo","parseKeyCombo","HotkeysContext","useHotkeys","keys","options","getDefaultDocument","_a","_b","showDialogKeyCombo","localKeys","useMemo","filter","k","global","map","combo","config","globalKeys","useContext","state","dispatch","hasProvider","useEffect","warn","payload","type","invokeNamedCallbackIfComboRecognized","callbackName","e","isTextInput","isTargetATextInput","_i","key","_e","allowInInput","_f","disabled","_g","preventDefault","_h","stopPropagation","shouldIgnore","isPropagationStopped","handleGlobalKeyDown","useCallback","handleGlobalKeyUp","handleLocalKeyDown","nativeEvent","handleLocalKeyUp","document","addEventListener","removeEventListener","handleKeyDown","handleKeyUp","elem","target","closest","editable","tagName","toLowerCase","inputType","readOnly","window","undefined"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/hooks/hotkeys/useHotkeys.ts"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as React from \"react\";\n\nimport { HOTKEYS_PROVIDER_NOT_FOUND } from \"../../common/errors\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"../../components/hotkeys/hotkeyParser\";\nimport { HotkeysContext } from \"../../context\";\nimport { HotkeyConfig } from \"./hotkeyConfig\";\n\nexport interface UseHotkeysOptions {\n    /**\n     * A custom document to reference when binding global event handlers.\n     * This can be useful when using iframes in an application.\n     *\n     * @default window.document\n     */\n    document?: Document;\n\n    /**\n     * The key combo which will trigger the hotkeys dialog to open.\n     *\n     * @default \"?\"\n     */\n    showDialogKeyCombo?: string;\n}\n\nexport interface UseHotkeysReturnValue {\n    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;\n    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;\n}\n\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nexport function useHotkeys(keys: readonly HotkeyConfig[], options: UseHotkeysOptions = {}): UseHotkeysReturnValue {\n    const { document = getDefaultDocument(), showDialogKeyCombo = \"?\" } = options;\n    const localKeys = React.useMemo(\n        () =>\n            keys\n                .filter(k => !k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n    const globalKeys = React.useMemo(\n        () =>\n            keys\n                .filter(k => k.global)\n                .map(k => ({\n                    combo: parseKeyCombo(k.combo),\n                    config: k,\n                })),\n        [keys],\n    );\n\n    // register keys with global context\n    const [state, dispatch] = React.useContext(HotkeysContext);\n\n    if (!state.hasProvider) {\n        React.useEffect(() => console.warn(HOTKEYS_PROVIDER_NOT_FOUND), []);\n    }\n\n    // we can still bind the hotkeys if there is no HotkeysProvider, they just won't show up in the dialog\n    React.useEffect(() => {\n        const payload = [...globalKeys.map(k => k.config), ...localKeys.map(k => k.config)];\n        dispatch({ type: \"ADD_HOTKEYS\", payload });\n        return () => dispatch({ type: \"REMOVE_HOTKEYS\", payload });\n    }, [keys]);\n\n    const invokeNamedCallbackIfComboRecognized = (\n        global: boolean,\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) => {\n        const isTextInput = isTargetATextInput(e);\n        for (const key of global ? globalKeys : localKeys) {\n            const {\n                allowInInput = false,\n                disabled = false,\n                preventDefault = false,\n                stopPropagation = false,\n            } = key.config;\n            const shouldIgnore = (isTextInput && !allowInInput) || disabled;\n            if (!shouldIgnore && comboMatches(key.combo, combo)) {\n                if (preventDefault) {\n                    e.preventDefault();\n                }\n                if (stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                key.config[callbackName]?.(e);\n            }\n        }\n    };\n\n    const handleGlobalKeyDown = React.useCallback(\n        (e: KeyboardEvent) => {\n            // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n            const combo = getKeyCombo(e);\n            const isTextInput = isTargetATextInput(e);\n            if (!isTextInput && comboMatches(parseKeyCombo(showDialogKeyCombo), combo)) {\n                dispatch({ type: \"OPEN_DIALOG\" });\n            } else {\n                invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyDown\", e);\n            }\n        },\n        [globalKeys],\n    );\n    const handleGlobalKeyUp = React.useCallback(\n        (e: KeyboardEvent) => invokeNamedCallbackIfComboRecognized(true, getKeyCombo(e), \"onKeyUp\", e),\n        [globalKeys],\n    );\n\n    const handleLocalKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent),\n        [localKeys],\n    );\n    const handleLocalKeyUp = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) =>\n            invokeNamedCallbackIfComboRecognized(false, getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent),\n        [localKeys],\n    );\n\n    React.useEffect(() => {\n        // document is guaranteed to be defined inside effects\n        document!.addEventListener(\"keydown\", handleGlobalKeyDown);\n        document!.addEventListener(\"keyup\", handleGlobalKeyUp);\n        return () => {\n            document!.removeEventListener(\"keydown\", handleGlobalKeyDown);\n            document!.removeEventListener(\"keyup\", handleGlobalKeyUp);\n        };\n    }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n\n    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };\n}\n\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\nfunction isTargetATextInput(e: KeyboardEvent) {\n    const elem = e.target as HTMLElement;\n    // we check these cases for unit testing, but this should not happen\n    // during normal operation\n    if (elem == null || elem.closest == null) {\n        return false;\n    }\n\n    const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n    if (editable == null) {\n        return false;\n    }\n\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n    if (editable.tagName.toLowerCase() === \"input\") {\n        const inputType = (editable as HTMLInputElement).type;\n        if (inputType === \"checkbox\" || inputType === \"radio\") {\n            return false;\n        }\n    }\n\n    // don't let read-only fields prevent hotkey behavior\n    if ((editable as HTMLInputElement).readOnly) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction getDefaultDocument(): Document | undefined {\n    if (typeof window === \"undefined\") {\n        return undefined;\n    }\n    return window.document;\n}\n"]},"metadata":{},"sourceType":"module"}