{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\"; // we need some empty interfaces to show up in docs\n// HACKHACK: these components should go in separate files\n\n/* eslint-disable max-classes-per-file, @typescript-eslint/no-empty-interface */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, refHandler, setRef } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\n/**\n * Renders common control elements, with additional props to customize appearance.\n * This component is not exported and is only used in this file for `Checkbox`, `Radio`, and `Switch` below.\n */\n\nvar Control = function (_a) {\n  var _b;\n\n  var alignIndicator = _a.alignIndicator,\n      children = _a.children,\n      className = _a.className,\n      indicatorChildren = _a.indicatorChildren,\n      inline = _a.inline,\n      inputRef = _a.inputRef,\n      label = _a.label,\n      labelElement = _a.labelElement,\n      large = _a.large,\n      style = _a.style,\n      type = _a.type,\n      typeClassName = _a.typeClassName,\n      _c = _a.tagName,\n      tagName = _c === void 0 ? \"label\" : _c,\n      htmlProps = __rest(_a, [\"alignIndicator\", \"children\", \"className\", \"indicatorChildren\", \"inline\", \"inputRef\", \"label\", \"labelElement\", \"large\", \"style\", \"type\", \"typeClassName\", \"tagName\"]);\n\n  var classes = classNames(Classes.CONTROL, typeClassName, (_b = {}, _b[Classes.DISABLED] = htmlProps.disabled, _b[Classes.INLINE] = inline, _b[Classes.LARGE] = large, _b), Classes.alignmentClass(alignIndicator), className);\n  return React.createElement(tagName, {\n    className: classes,\n    style: style\n  }, React.createElement(\"input\", __assign({}, htmlProps, {\n    ref: inputRef,\n    type: type\n  })), React.createElement(\"span\", {\n    className: Classes.CONTROL_INDICATOR\n  }, indicatorChildren), label, labelElement, children);\n};\n\nvar Switch =\n/** @class */\nfunction (_super) {\n  __extends(Switch, _super);\n\n  function Switch() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Switch.prototype.render = function () {\n    var _a = this.props,\n        innerLabelChecked = _a.innerLabelChecked,\n        innerLabel = _a.innerLabel,\n        controlProps = __rest(_a, [\"innerLabelChecked\", \"innerLabel\"]);\n\n    var switchLabels = innerLabel || innerLabelChecked ? [React.createElement(\"div\", {\n      key: \"checked\",\n      className: Classes.CONTROL_INDICATOR_CHILD\n    }, React.createElement(\"div\", {\n      className: Classes.SWITCH_INNER_TEXT\n    }, innerLabelChecked ? innerLabelChecked : innerLabel)), React.createElement(\"div\", {\n      key: \"unchecked\",\n      className: Classes.CONTROL_INDICATOR_CHILD\n    }, React.createElement(\"div\", {\n      className: Classes.SWITCH_INNER_TEXT\n    }, innerLabel))] : null;\n    return React.createElement(Control, __assign({}, controlProps, {\n      type: \"checkbox\",\n      typeClassName: Classes.SWITCH,\n      indicatorChildren: switchLabels\n    }));\n  };\n\n  Switch.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Switch\");\n  return Switch;\n}(AbstractPureComponent2);\n\nexport { Switch };\n\nvar Radio =\n/** @class */\nfunction (_super) {\n  __extends(Radio, _super);\n\n  function Radio() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Radio.prototype.render = function () {\n    return React.createElement(Control, __assign({}, this.props, {\n      type: \"radio\",\n      typeClassName: Classes.RADIO\n    }));\n  };\n\n  Radio.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Radio\");\n  return Radio;\n}(AbstractPureComponent2);\n\nexport { Radio };\n\nvar Checkbox =\n/** @class */\nfunction (_super) {\n  __extends(Checkbox, _super);\n\n  function Checkbox() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      indeterminate: _this.props.indeterminate || _this.props.defaultIndeterminate || false\n    }; // must maintain internal reference for `indeterminate` support\n\n    _this.input = null;\n    _this.handleInputRef = refHandler(_this, \"input\", _this.props.inputRef);\n\n    _this.handleChange = function (evt) {\n      var _a, _b;\n\n      var indeterminate = evt.target.indeterminate; // update state immediately only if uncontrolled\n\n      if (_this.props.indeterminate == null) {\n        _this.setState({\n          indeterminate: indeterminate\n        });\n      } // otherwise wait for props change. always invoke handler.\n\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, evt);\n    };\n\n    return _this;\n  }\n\n  Checkbox.getDerivedStateFromProps = function (_a) {\n    var indeterminate = _a.indeterminate; // put props into state if controlled by props\n\n    if (indeterminate != null) {\n      return {\n        indeterminate: indeterminate\n      };\n    }\n\n    return null;\n  };\n\n  Checkbox.prototype.render = function () {\n    var _a = this.props,\n        defaultIndeterminate = _a.defaultIndeterminate,\n        indeterminate = _a.indeterminate,\n        controlProps = __rest(_a, [\"defaultIndeterminate\", \"indeterminate\"]);\n\n    return React.createElement(Control, __assign({}, controlProps, {\n      inputRef: this.handleInputRef,\n      onChange: this.handleChange,\n      type: \"checkbox\",\n      typeClassName: Classes.CHECKBOX\n    }));\n  };\n\n  Checkbox.prototype.componentDidMount = function () {\n    this.updateIndeterminate();\n  };\n\n  Checkbox.prototype.componentDidUpdate = function (prevProps) {\n    this.updateIndeterminate();\n\n    if (prevProps.inputRef !== this.props.inputRef) {\n      setRef(prevProps.inputRef, null);\n      this.handleInputRef = refHandler(this, \"input\", this.props.inputRef);\n      setRef(this.props.inputRef, this.input);\n    }\n  };\n\n  Checkbox.prototype.updateIndeterminate = function () {\n    if (this.input != null) {\n      this.input.indeterminate = this.state.indeterminate;\n    }\n  };\n\n  Checkbox.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Checkbox\");\n  return Checkbox;\n}(AbstractPureComponent2);\n\nexport { Checkbox };","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;qDAgBA;AACA;;AACA;;AAEA,OAAOA,UAAP,MAAuB,YAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AAEA,SAASC,sBAAT,EAA4CC,OAA5C,EAA2DC,UAA3D,EAAuEC,MAAvE,QAAqF,cAArF;AACA,SAASC,kBAAT,QAA0D,oBAA1D;AA2EA;;;;;AAIA,IAAMC,OAAO,GAAoC,UAACC,EAAD,EAehD;;;EAdG,kBAAc,oBAAd;EAAA,IACAC,QAAQ,cADR;EAAA,IAEAC,SAAS,eAFT;EAAA,IAGAC,iBAAiB,uBAHjB;EAAA,IAIAC,MAAM,YAJN;EAAA,IAKAC,QAAQ,cALR;EAAA,IAMAC,KAAK,WANL;EAAA,IAOAC,YAAY,kBAPZ;EAAA,IAQAC,KAAK,WARL;EAAA,IASAC,KAAK,WATL;EAAA,IAUAC,IAAI,UAVJ;EAAA,IAWAC,aAAa,mBAXb;EAAA,IAYAC,eAZA;EAAA,IAYAC,OAAO,mBAAG,OAAH,GAAUD,EAZjB;EAAA,IAaGE,SAAS,cAdkC,qKAclC,CAbZ;;EAeA,IAAMC,OAAO,GAAGvB,UAAU,CACtBG,OAAO,CAACqB,OADc,EAEtBL,aAFsB,GAETM,SAETA,GAACtB,OAAO,CAACuB,QAAT,IAAoBJ,SAAS,CAACK,QAFrB,EAGTF,GAACtB,OAAO,CAACyB,MAAT,IAAkBhB,MAHT,EAITa,GAACtB,OAAO,CAAC0B,KAAT,IAAiBb,KAJR,IAFS,GAQtBb,OAAO,CAAC2B,cAAR,CAAuBC,cAAvB,CARsB,EAStBrB,SATsB,CAA1B;EAYA,OAAOT,KAAK,CAAC+B,aAAN,CACHX,OADG,EAEH;IAAEX,SAAS,EAAEa,OAAb;IAAsBN,KAAK;EAA3B,CAFG,EAGHhB,0CAAWqB,SAAX,EAAoB;IAAEW,GAAG,EAAEpB,QAAP;IAAiBK,IAAI,EAAEA;EAAvB,CAApB,EAHG,EAIHjB;IAAMS,SAAS,EAAEP,OAAO,CAAC+B;EAAzB,GAA6CvB,iBAA7C,CAJG,EAKHG,KALG,EAMHC,YANG,EAOHN,QAPG,CAAP;AASH,CArCD;;AA8DA;AAAA;AAAA;EAA4B0B;;EAA5B;;EA2BC;;EAxBUC,0BAAP;IACI,IAAM5B,KAAqD,KAAK6B,KAAhE;IAAA,IAAQC,iBAAiB,uBAAzB;IAAA,IAA2BC,UAAU,gBAArC;IAAA,IAA0CC,YAAY,cAAhD,mCAAgD,CAAtD;;IACA,IAAMC,YAAY,GACdF,UAAU,IAAID,iBAAd,GACM,CACIrC;MAAKyC,GAAG,EAAC,SAAT;MAAmBhC,SAAS,EAAEP,OAAO,CAACwC;IAAtC,GACI1C;MAAKS,SAAS,EAAEP,OAAO,CAACyC;IAAxB,GACKN,iBAAiB,GAAGA,iBAAH,GAAuBC,UAD7C,CADJ,CADJ,EAMItC;MAAKyC,GAAG,EAAC,WAAT;MAAqBhC,SAAS,EAAEP,OAAO,CAACwC;IAAxC,GACI1C;MAAKS,SAAS,EAAEP,OAAO,CAACyC;IAAxB,GAA4CL,UAA5C,CADJ,CANJ,CADN,GAWM,IAZV;IAaA,OACItC,oBAACM,OAAD,EAAQsC,aACAL,YADA,EACY;MAChBtB,IAAI,EAAC,UADW;MAEhBC,aAAa,EAAEhB,OAAO,CAAC2C,MAFP;MAGhBnC,iBAAiB,EAAE8B;IAHH,CADZ,CAAR,CADJ;EAQH,CAvBM;;EAFOL,qBAAc,UAAG9B,kBAAH,EAAqB,SAArB,CAAd;EA0BlB;AAAC,CA3BD,CAA4BJ,sBAA5B;;SAAakC;;AAsCb;AAAA;AAAA;EAA2BD;;EAA3B;;EAMC;;EAHUY,yBAAP;IACI,OAAO9C,oBAACM,OAAD,EAAQsC,aAAK,KAAKR,KAAV,EAAe;MAAEnB,IAAI,EAAC,OAAP;MAAeC,aAAa,EAAEhB,OAAO,CAAC6C;IAAtC,CAAf,CAAR,CAAP;EACH,CAFM;;EAFOD,oBAAc,UAAGzC,kBAAH,EAAqB,QAArB,CAAd;EAKlB;AAAC,CAND,CAA2BJ,sBAA3B;;SAAa6C;;AAmCb;AAAA;AAAA;EAA8BZ;;EAA9B;IAAA;;IAYWc,cAAwB;MAC3BC,aAAa,EAAED,KAAI,CAACZ,KAAL,CAAWa,aAAX,IAA4BD,KAAI,CAACZ,KAAL,CAAWc,oBAAvC,IAA+D;IADnD,CAAxB,CAZX,CAgBI;;IACOF,cAAiC,IAAjC;IAECA,uBAAyC7C,UAAU,CAAC6C,KAAD,EAAO,OAAP,EAAgBA,KAAI,CAACZ,KAAL,CAAWxB,QAA3B,CAAnD;;IAkCAoC,qBAAe,UAACG,GAAD,EAAyC;;;MACpD,iBAAa,GAAKA,GAAG,CAACC,MAAJ,CAAUH,aAA5B,CADoD,CAE5D;;MACA,IAAID,KAAI,CAACZ,KAAL,CAAWa,aAAX,IAA4B,IAAhC,EAAsC;QAClCD,KAAI,CAACK,QAAL,CAAc;UAAEJ,aAAa;QAAf,CAAd;MACH,CAL2D,CAM5D;;;MACA,iBAAI,CAACb,KAAL,EAAWkB,QAAX,MAAmB,IAAnB,IAAmB9B,aAAnB,GAAmB,MAAnB,GAAmBA,YAAG2B,GAAH,CAAnB;IACH,CARO;;;EASX;;EA3DiBI,oCAAd,UAAuChD,EAAvC,EAAuE;QAA9B0C,aAAa,oBAAiB,CACnE;;IACA,IAAIA,aAAa,IAAI,IAArB,EAA2B;MACvB,OAAO;QAAEA,aAAa;MAAf,CAAP;IACH;;IAED,OAAO,IAAP;EACH,CAPa;;EAkBPM,4BAAP;IACI,IAAMhD,KAA2D,KAAK6B,KAAtE;IAAA,IAAQc,oBAAoB,0BAA5B;IAAA,IAA8BD,aAAa,mBAA3C;IAAA,IAAgDV,YAAY,cAAtD,yCAAsD,CAA5D;;IACA,OACIvC,oBAACM,OAAD,EAAQsC,aACAL,YADA,EACY;MAChB3B,QAAQ,EAAE,KAAK4C,cADC;MAEhBF,QAAQ,EAAE,KAAKG,YAFC;MAGhBxC,IAAI,EAAC,UAHW;MAIhBC,aAAa,EAAEhB,OAAO,CAACwD;IAJP,CADZ,CAAR,CADJ;EASH,CAXM;;EAaAH,uCAAP;IACI,KAAKI,mBAAL;EACH,CAFM;;EAIAJ,wCAAP,UAA0BK,SAA1B,EAAkD;IAC9C,KAAKD,mBAAL;;IACA,IAAIC,SAAS,CAAChD,QAAV,KAAuB,KAAKwB,KAAL,CAAWxB,QAAtC,EAAgD;MAC5CR,MAAM,CAACwD,SAAS,CAAChD,QAAX,EAAqB,IAArB,CAAN;MACA,KAAK4C,cAAL,GAAsBrD,UAAU,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAKiC,KAAL,CAAWxB,QAA3B,CAAhC;MACAR,MAAM,CAAC,KAAKgC,KAAL,CAAWxB,QAAZ,EAAsB,KAAKiD,KAA3B,CAAN;IACH;EACJ,CAPM;;EASCN,yCAAR;IACI,IAAI,KAAKM,KAAL,IAAc,IAAlB,EAAwB;MACpB,KAAKA,KAAL,CAAWZ,aAAX,GAA2B,KAAKa,KAAL,CAAWb,aAAtC;IACH;EACJ,CAJO;;EA9CMM,uBAAc,UAAGlD,kBAAH,EAAqB,WAArB,CAAd;EA6DlB;AAAC,CA9DD,CAA8BJ,sBAA9B;;SAAasD","names":["classNames","React","AbstractPureComponent2","Classes","refHandler","setRef","DISPLAYNAME_PREFIX","Control","_a","children","className","indicatorChildren","inline","inputRef","label","labelElement","large","style","type","typeClassName","_c","tagName","htmlProps","classes","CONTROL","_b","DISABLED","disabled","INLINE","LARGE","alignmentClass","alignIndicator","createElement","ref","CONTROL_INDICATOR","__extends","Switch","props","innerLabelChecked","innerLabel","controlProps","switchLabels","key","CONTROL_INDICATOR_CHILD","SWITCH_INNER_TEXT","__assign","SWITCH","Radio","RADIO","_this","indeterminate","defaultIndeterminate","evt","target","setState","onChange","Checkbox","handleInputRef","handleChange","CHECKBOX","updateIndeterminate","prevProps","input","state"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/components/forms/controls.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// we need some empty interfaces to show up in docs\n// HACKHACK: these components should go in separate files\n/* eslint-disable max-classes-per-file, @typescript-eslint/no-empty-interface */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Alignment, Classes, IRef, refHandler, setRef } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, HTMLInputProps, Props } from \"../../common/props\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type ControlProps = IControlProps;\n/** @deprecated use ControlProps */\nexport interface IControlProps extends Props, HTMLInputProps {\n    // NOTE: HTML props are duplicated here to provide control-specific documentation\n\n    /**\n     * Alignment of the indicator within container.\n     *\n     * @default Alignment.LEFT\n     */\n    alignIndicator?: Alignment;\n\n    /** Whether the control is checked. */\n    checked?: boolean;\n\n    /** JSX label for the control. */\n    children?: React.ReactNode;\n\n    /** Whether the control is initially checked (uncontrolled mode). */\n    defaultChecked?: boolean;\n\n    /** Whether the control is non-interactive. */\n    disabled?: boolean;\n\n    /** Ref handler that receives HTML `<input>` element backing this component. */\n    inputRef?: IRef<HTMLInputElement>;\n\n    /** Whether the control should appear as an inline element. */\n    inline?: boolean;\n\n    /**\n     * Text label for the control.\n     *\n     * Use `children` or `labelElement` to supply JSX content. This prop actually supports JSX elements,\n     * but TypeScript will throw an error because `HTMLAttributes` only allows strings.\n     */\n    label?: string;\n\n    /**\n     * JSX Element label for the control.\n     *\n     * This prop is a workaround for TypeScript consumers as the type definition for `label` only\n     * accepts strings. JavaScript consumers can provide a JSX element directly to `label`.\n     */\n    labelElement?: React.ReactNode;\n\n    /** Whether this control should use large styles. */\n    large?: boolean;\n\n    /** Event handler invoked when input value is changed. */\n    onChange?: React.FormEventHandler<HTMLInputElement>;\n\n    /**\n     * Name of the HTML tag that wraps the checkbox.\n     *\n     * By default a `<label>` is used, which effectively enlarges the click\n     * target to include all of its children. Supply a different tag name if\n     * this behavior is undesirable or you're listening to click events from a\n     * parent element (as the label can register duplicate clicks).\n     *\n     * @default \"label\"\n     */\n    tagName?: keyof JSX.IntrinsicElements;\n}\n\n/** Internal props for Checkbox/Radio/Switch to render correctly. */\ninterface IControlInternalProps extends ControlProps {\n    type: \"checkbox\" | \"radio\";\n    typeClassName: string;\n    indicatorChildren?: React.ReactNode;\n}\n\n/**\n * Renders common control elements, with additional props to customize appearance.\n * This component is not exported and is only used in this file for `Checkbox`, `Radio`, and `Switch` below.\n */\nconst Control: React.FC<IControlInternalProps> = ({\n    alignIndicator,\n    children,\n    className,\n    indicatorChildren,\n    inline,\n    inputRef,\n    label,\n    labelElement,\n    large,\n    style,\n    type,\n    typeClassName,\n    tagName = \"label\",\n    ...htmlProps\n}) => {\n    const classes = classNames(\n        Classes.CONTROL,\n        typeClassName,\n        {\n            [Classes.DISABLED]: htmlProps.disabled,\n            [Classes.INLINE]: inline,\n            [Classes.LARGE]: large,\n        },\n        Classes.alignmentClass(alignIndicator),\n        className,\n    );\n\n    return React.createElement(\n        tagName,\n        { className: classes, style },\n        <input {...htmlProps} ref={inputRef} type={type} />,\n        <span className={Classes.CONTROL_INDICATOR}>{indicatorChildren}</span>,\n        label,\n        labelElement,\n        children,\n    );\n};\n\n//\n// Switch\n//\n\n// eslint-disable-next-line deprecation/deprecation\nexport type SwitchProps = ISwitchProps;\n/** @deprecated use SwitchProps */\nexport interface ISwitchProps extends ControlProps {\n    /**\n     * Text to display inside the switch indicator when checked.\n     * If `innerLabel` is provided and this prop is omitted, then `innerLabel`\n     * will be used for both states.\n     *\n     * @default innerLabel\n     */\n    innerLabelChecked?: string;\n\n    /**\n     * Text to display inside the switch indicator when unchecked.\n     */\n    innerLabel?: string;\n}\n\nexport class Switch extends AbstractPureComponent2<SwitchProps> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Switch`;\n\n    public render() {\n        const { innerLabelChecked, innerLabel, ...controlProps } = this.props;\n        const switchLabels =\n            innerLabel || innerLabelChecked\n                ? [\n                      <div key=\"checked\" className={Classes.CONTROL_INDICATOR_CHILD}>\n                          <div className={Classes.SWITCH_INNER_TEXT}>\n                              {innerLabelChecked ? innerLabelChecked : innerLabel}\n                          </div>\n                      </div>,\n                      <div key=\"unchecked\" className={Classes.CONTROL_INDICATOR_CHILD}>\n                          <div className={Classes.SWITCH_INNER_TEXT}>{innerLabel}</div>\n                      </div>,\n                  ]\n                : null;\n        return (\n            <Control\n                {...controlProps}\n                type=\"checkbox\"\n                typeClassName={Classes.SWITCH}\n                indicatorChildren={switchLabels}\n            />\n        );\n    }\n}\n\n//\n// Radio\n//\n\n/** @deprecated use RadioProps */\nexport type IRadioProps = ControlProps;\n// eslint-disable-next-line deprecation/deprecation\nexport type RadioProps = IRadioProps;\n\nexport class Radio extends AbstractPureComponent2<RadioProps> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Radio`;\n\n    public render() {\n        return <Control {...this.props} type=\"radio\" typeClassName={Classes.RADIO} />;\n    }\n}\n\n//\n// Checkbox\n//\n\n// eslint-disable-next-line deprecation/deprecation\nexport type CheckboxProps = ICheckboxProps;\n/** @deprecated use CheckboxProps */\nexport interface ICheckboxProps extends ControlProps {\n    /** Whether this checkbox is initially indeterminate (uncontrolled mode). */\n    defaultIndeterminate?: boolean;\n\n    /**\n     * Whether this checkbox is indeterminate, or \"partially checked.\"\n     * The checkbox will appear with a small dash instead of a tick to indicate that the value\n     * is not exactly true or false.\n     *\n     * Note that this prop takes precendence over `checked`: if a checkbox is marked both\n     * `checked` and `indeterminate` via props, it will appear as indeterminate in the DOM.\n     */\n    indeterminate?: boolean;\n}\n\nexport interface ICheckboxState {\n    // Checkbox adds support for uncontrolled indeterminate state\n    indeterminate: boolean;\n}\n\nexport class Checkbox extends AbstractPureComponent2<CheckboxProps, ICheckboxState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Checkbox`;\n\n    public static getDerivedStateFromProps({ indeterminate }: CheckboxProps): ICheckboxState | null {\n        // put props into state if controlled by props\n        if (indeterminate != null) {\n            return { indeterminate };\n        }\n\n        return null;\n    }\n\n    public state: ICheckboxState = {\n        indeterminate: this.props.indeterminate || this.props.defaultIndeterminate || false,\n    };\n\n    // must maintain internal reference for `indeterminate` support\n    public input: HTMLInputElement | null = null;\n\n    private handleInputRef: IRef<HTMLInputElement> = refHandler(this, \"input\", this.props.inputRef);\n\n    public render() {\n        const { defaultIndeterminate, indeterminate, ...controlProps } = this.props;\n        return (\n            <Control\n                {...controlProps}\n                inputRef={this.handleInputRef}\n                onChange={this.handleChange}\n                type=\"checkbox\"\n                typeClassName={Classes.CHECKBOX}\n            />\n        );\n    }\n\n    public componentDidMount() {\n        this.updateIndeterminate();\n    }\n\n    public componentDidUpdate(prevProps: CheckboxProps) {\n        this.updateIndeterminate();\n        if (prevProps.inputRef !== this.props.inputRef) {\n            setRef(prevProps.inputRef, null);\n            this.handleInputRef = refHandler(this, \"input\", this.props.inputRef);\n            setRef(this.props.inputRef, this.input);\n        }\n    }\n\n    private updateIndeterminate() {\n        if (this.input != null) {\n            this.input.indeterminate = this.state.indeterminate;\n        }\n    }\n\n    private handleChange = (evt: React.ChangeEvent<HTMLInputElement>) => {\n        const { indeterminate } = evt.target;\n        // update state immediately only if uncontrolled\n        if (this.props.indeterminate == null) {\n            this.setState({ indeterminate });\n        }\n        // otherwise wait for props change. always invoke handler.\n        this.props.onChange?.(evt);\n    };\n}\n"]},"metadata":{},"sourceType":"module"}