{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\nvar BUFFER_WIDTH_DEFAULT = 5;\nvar BUFFER_WIDTH_IE = 30;\n\nvar EditableText =\n/** @class */\nfunction (_super) {\n  __extends(EditableText, _super);\n\n  function EditableText(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.inputElement = null;\n    _this.valueElement = null;\n    _this.refHandlers = {\n      content: function (spanElement) {\n        _this.valueElement = spanElement;\n      },\n      input: function (input) {\n        if (input != null) {\n          _this.inputElement = input; // temporary fix for #3882\n\n          if (!_this.props.alwaysRenderInput) {\n            _this.inputElement.focus();\n          }\n\n          if (_this.state != null && _this.state.isEditing) {\n            var supportsSelection = inputSupportsSelection(input);\n\n            if (supportsSelection) {\n              var length_1 = input.value.length;\n              input.setSelectionRange(_this.props.selectAllOnFocus ? 0 : length_1, length_1);\n            }\n\n            if (!supportsSelection || !_this.props.selectAllOnFocus) {\n              input.scrollLeft = input.scrollWidth;\n            }\n          }\n        }\n      }\n    };\n\n    _this.cancelEditing = function () {\n      var _a, _b, _c, _d;\n\n      var _e = _this.state,\n          lastValue = _e.lastValue,\n          value = _e.value;\n\n      _this.setState({\n        isEditing: false,\n        value: lastValue\n      });\n\n      if (value !== lastValue) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, lastValue);\n      }\n\n      (_d = (_c = _this.props).onCancel) === null || _d === void 0 ? void 0 : _d.call(_c, lastValue);\n    };\n\n    _this.toggleEditing = function () {\n      var _a, _b;\n\n      if (_this.state.isEditing) {\n        var value = _this.state.value;\n\n        _this.setState({\n          isEditing: false,\n          lastValue: value\n        });\n\n        (_b = (_a = _this.props).onConfirm) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n      } else if (!_this.props.disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n    };\n\n    _this.handleFocus = function () {\n      var _a = _this.props,\n          alwaysRenderInput = _a.alwaysRenderInput,\n          disabled = _a.disabled,\n          selectAllOnFocus = _a.selectAllOnFocus;\n\n      if (!disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n\n      if (alwaysRenderInput && selectAllOnFocus && _this.inputElement != null) {\n        var length_2 = _this.inputElement.value.length;\n\n        _this.inputElement.setSelectionRange(0, length_2);\n      }\n    };\n\n    _this.handleTextChange = function (event) {\n      var _a, _b;\n\n      var value = event.target.value; // state value should be updated only when uncontrolled\n\n      if (_this.props.value == null) {\n        _this.setState({\n          value: value\n        });\n      }\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n\n    _this.handleKeyEvent = function (event) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n      var altKey = event.altKey,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey,\n          shiftKey = event.shiftKey,\n          which = event.which;\n\n      if (which === Keys.ESCAPE) {\n        _this.cancelEditing();\n\n        return;\n      }\n\n      var hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n\n      if (which === Keys.ENTER) {\n        // prevent IE11 from full screening with alt + enter\n        // shift + enter adds a newline by default\n        if (altKey || shiftKey) {\n          event.preventDefault();\n        }\n\n        if (_this.props.confirmOnEnterKey && _this.props.multiline) {\n          if (event.target != null && hasModifierKey) {\n            insertAtCaret(event.target, \"\\n\");\n\n            _this.handleTextChange(event);\n          } else {\n            _this.toggleEditing();\n          }\n        } else if (!_this.props.multiline || hasModifierKey) {\n          _this.toggleEditing();\n        }\n      }\n    };\n\n    var value = props.value == null ? props.defaultValue : props.value;\n    _this.state = {\n      inputHeight: 0,\n      inputWidth: 0,\n      isEditing: props.isEditing === true && props.disabled === false,\n      lastValue: value,\n      value: value\n    };\n    return _this;\n  }\n\n  EditableText.prototype.render = function () {\n    var _a;\n\n    var _b;\n\n    var _c = this.props,\n        alwaysRenderInput = _c.alwaysRenderInput,\n        disabled = _c.disabled,\n        multiline = _c.multiline,\n        contentId = _c.contentId;\n    var value = (_b = this.props.value) !== null && _b !== void 0 ? _b : this.state.value;\n    var hasValue = value != null && value !== \"\";\n    var classes = classNames(Classes.EDITABLE_TEXT, Classes.intentClass(this.props.intent), (_a = {}, _a[Classes.DISABLED] = disabled, _a[Classes.EDITABLE_TEXT_EDITING] = this.state.isEditing, _a[Classes.EDITABLE_TEXT_PLACEHOLDER] = !hasValue, _a[Classes.MULTILINE] = multiline, _a), this.props.className);\n    var contentStyle;\n\n    if (multiline) {\n      // set height only in multiline mode when not editing\n      // otherwise we're measuring this element to determine appropriate height of text\n      contentStyle = {\n        height: !this.state.isEditing ? this.state.inputHeight : undefined\n      };\n    } else {\n      // minWidth only applies in single line mode (multiline == width 100%)\n      contentStyle = {\n        height: this.state.inputHeight,\n        lineHeight: this.state.inputHeight != null ? \"\".concat(this.state.inputHeight, \"px\") : undefined,\n        minWidth: this.props.minWidth\n      };\n    } // If we are always rendering an input, then NEVER make the container div focusable.\n    // Otherwise, make container div focusable when not editing, so it can still be tabbed\n    // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n\n\n    var tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0; // we need the contents to be rendered while editing so that we can measure their height\n    // and size the container element responsively\n\n    var shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n    var spanProps = contentId != null ? {\n      id: contentId\n    } : {};\n    return React.createElement(\"div\", {\n      className: classes,\n      onFocus: this.handleFocus,\n      tabIndex: tabIndex\n    }, alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined, shouldHideContents ? undefined : React.createElement(\"span\", __assign({}, spanProps, {\n      className: Classes.EDITABLE_TEXT_CONTENT,\n      ref: this.refHandlers.content,\n      style: contentStyle\n    }), hasValue ? value : this.props.placeholder));\n  };\n\n  EditableText.prototype.componentDidMount = function () {\n    this.updateInputDimensions();\n  };\n\n  EditableText.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    var newState = {}; // allow setting the value to undefined/null in controlled mode\n\n    if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n      newState.value = this.props.value;\n    }\n\n    if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n      newState.isEditing = this.props.isEditing;\n    }\n\n    if (this.props.disabled || this.props.disabled == null && prevProps.disabled) {\n      newState.isEditing = false;\n    }\n\n    this.setState(newState);\n\n    if (this.state.isEditing && !prevState.isEditing) {\n      (_b = (_a = this.props).onEdit) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.value);\n    } // updateInputDimensions is an expensive method. Call it only when the props\n    // it depends on change\n\n\n    if (this.state.value !== prevState.value || this.props.alwaysRenderInput !== prevProps.alwaysRenderInput || this.props.maxLines !== prevProps.maxLines || this.props.minLines !== prevProps.minLines || this.props.minWidth !== prevProps.minWidth || this.props.multiline !== prevProps.multiline) {\n      this.updateInputDimensions();\n    }\n  };\n\n  EditableText.prototype.renderInput = function (value) {\n    var _a = this.props,\n        disabled = _a.disabled,\n        maxLength = _a.maxLength,\n        multiline = _a.multiline,\n        type = _a.type,\n        placeholder = _a.placeholder;\n    var props = {\n      className: Classes.EDITABLE_TEXT_INPUT,\n      disabled: disabled,\n      maxLength: maxLength,\n      onBlur: this.toggleEditing,\n      onChange: this.handleTextChange,\n      onKeyDown: this.handleKeyEvent,\n      placeholder: placeholder,\n      value: value\n    };\n    var _b = this.state,\n        inputHeight = _b.inputHeight,\n        inputWidth = _b.inputWidth;\n\n    if (inputHeight !== 0 && inputWidth !== 0) {\n      props.style = {\n        height: inputHeight,\n        lineHeight: !multiline && inputHeight != null ? \"\".concat(inputHeight, \"px\") : undefined,\n        width: multiline ? \"100%\" : inputWidth\n      };\n    }\n\n    return multiline ? React.createElement(\"textarea\", __assign({\n      ref: this.refHandlers.input\n    }, props)) : React.createElement(\"input\", __assign({\n      ref: this.refHandlers.input,\n      type: type\n    }, props));\n  };\n\n  EditableText.prototype.updateInputDimensions = function () {\n    if (this.valueElement != null) {\n      var _a = this.props,\n          maxLines = _a.maxLines,\n          minLines = _a.minLines,\n          minWidth = _a.minWidth,\n          multiline = _a.multiline;\n      var _b = this.valueElement,\n          parentElement_1 = _b.parentElement,\n          textContent = _b.textContent;\n      var _c = this.valueElement,\n          scrollHeight_1 = _c.scrollHeight,\n          scrollWidth = _c.scrollWidth;\n      var lineHeight = getLineHeight(this.valueElement); // add one line to computed <span> height if text ends in newline\n      // because <span> collapses that trailing whitespace but <textarea> shows it\n\n      if (multiline && this.state.isEditing && /\\n$/.test(textContent !== null && textContent !== void 0 ? textContent : \"\")) {\n        scrollHeight_1 += lineHeight;\n      }\n\n      if (lineHeight > 0) {\n        // line height could be 0 if the isNaN block from getLineHeight kicks in\n        scrollHeight_1 = clamp(scrollHeight_1, minLines * lineHeight, maxLines * lineHeight);\n      } // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n      // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n\n\n      scrollHeight_1 = Math.max(scrollHeight_1, getFontSize(this.valueElement) + 1, getLineHeight(parentElement_1)); // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n      // IE needs a larger buffer than other browsers.\n\n      scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n      this.setState({\n        inputHeight: scrollHeight_1,\n        inputWidth: Math.max(scrollWidth, minWidth)\n      }); // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n\n      if (multiline && this.state.isEditing) {\n        this.setTimeout(function () {\n          return parentElement_1.style.height = \"\".concat(scrollHeight_1, \"px\");\n        });\n      }\n    }\n  };\n\n  EditableText.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".EditableText\");\n  EditableText.defaultProps = {\n    alwaysRenderInput: false,\n    confirmOnEnterKey: false,\n    defaultValue: \"\",\n    disabled: false,\n    maxLines: Infinity,\n    minLines: 1,\n    minWidth: 80,\n    multiline: false,\n    placeholder: \"Click to Edit\",\n    type: \"text\"\n  };\n  return EditableText;\n}(AbstractPureComponent2);\n\nexport { EditableText };\n\nfunction getFontSize(element) {\n  var fontSize = getComputedStyle(element).fontSize;\n  return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element) {\n  // getComputedStyle() => 18.0001px => 18\n  var lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10); // this check will be true if line-height is a keyword like \"normal\"\n\n  if (isNaN(lineHeight)) {\n    // @see http://stackoverflow.com/a/18430767/6342931\n    var line = document.createElement(\"span\");\n    line.innerHTML = \"<br>\";\n    element.appendChild(line);\n    var singleLineHeight = element.offsetHeight;\n    line.innerHTML = \"<br><br>\";\n    var doubleLineHeight = element.offsetHeight;\n    element.removeChild(line); // this can return 0 in edge cases\n\n    lineHeight = doubleLineHeight - singleLineHeight;\n  }\n\n  return lineHeight;\n}\n\nfunction insertAtCaret(el, text) {\n  var selectionEnd = el.selectionEnd,\n      selectionStart = el.selectionStart,\n      value = el.value;\n\n  if (selectionStart >= 0) {\n    var before_1 = value.substring(0, selectionStart);\n    var after_1 = value.substring(selectionEnd, value.length);\n    var len = text.length;\n    el.value = \"\".concat(before_1).concat(text).concat(after_1);\n    el.selectionStart = selectionStart + len;\n    el.selectionEnd = selectionStart + len;\n  }\n}\n\nfunction inputSupportsSelection(input) {\n  switch (input.type) {\n    // HTMLTextAreaElement\n    case \"textarea\":\n      return true;\n    // HTMLInputElement\n    // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n\n    case \"text\":\n    case \"search\":\n    case \"tel\":\n    case \"url\":\n    case \"password\":\n      return true;\n\n    default:\n      return false;\n  }\n}","map":{"version":3,"mappings":"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","names":["classNames","React","AbstractPureComponent2","Classes","Keys","DISPLAYNAME_PREFIX","clamp","Browser","BUFFER_WIDTH_DEFAULT","BUFFER_WIDTH_IE","__extends","props","context","_super","_this","content","spanElement","valueElement","input","inputElement","alwaysRenderInput","focus","state","isEditing","supportsSelection","inputSupportsSelection","value","length","setSelectionRange","selectAllOnFocus","length_1","scrollLeft","scrollWidth","lastValue","setState","onChange","_b","onCancel","_d","onConfirm","disabled","length_2","event","target","ctrlKey","metaKey","shiftKey","which","ESCAPE","cancelEditing","hasModifierKey","altKey","ENTER","preventDefault","confirmOnEnterKey","multiline","insertAtCaret","handleTextChange","toggleEditing","defaultValue","inputHeight","inputWidth","EditableText","contentId","hasValue","classes","EDITABLE_TEXT","intentClass","intent","_a","DISABLED","EDITABLE_TEXT_EDITING","EDITABLE_TEXT_PLACEHOLDER","MULTILINE","className","contentStyle","height","undefined","lineHeight","minWidth","tabIndex","shouldHideContents","spanProps","id","onFocus","handleFocus","renderInput","EDITABLE_TEXT_CONTENT","ref","refHandlers","style","placeholder","updateInputDimensions","prevProps","prevState","newState","onEdit","maxLines","minLines","maxLength","type","EDITABLE_TEXT_INPUT","onBlur","onKeyDown","handleKeyEvent","width","parentElement_1","textContent","scrollHeight_1","getLineHeight","test","Math","max","getFontSize","isInternetExplorer","setTimeout","Infinity","element","fontSize","getComputedStyle","parseInt","slice","isNaN","line","document","createElement","innerHTML","appendChild","singleLineHeight","offsetHeight","doubleLineHeight","removeChild","el","text","selectionStart","before_1","substring","after_1","selectionEnd","len","concat"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/components/editable-text/editableText.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX, IntentProps, Props } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\n\n// eslint-disable-next-line deprecation/deprecation\nexport type EditableTextProps = IEditableTextProps;\n/** @deprecated use EditableTextProps */\nexport interface IEditableTextProps extends IntentProps, Props {\n    /**\n     * EXPERIMENTAL FEATURE.\n     *\n     * When true, this forces the component to _always_ render an editable input (or textarea)\n     * both when the component is focussed and unfocussed, instead of the component's default\n     * behavior of switching between a text span and a text input upon interaction.\n     *\n     * This behavior can help in certain applications where, for example, a custom right-click\n     * context menu is used to supply clipboard copy and paste functionality.\n     *\n     * @default false\n     */\n    alwaysRenderInput?: boolean;\n\n    /**\n     * If `true` and in multiline mode, the `enter` key will trigger onConfirm and `mod+enter`\n     * will insert a newline. If `false`, the key bindings are inverted such that `enter`\n     * adds a newline.\n     *\n     * @default false\n     */\n    confirmOnEnterKey?: boolean;\n\n    /** Default text value of uncontrolled input. */\n    defaultValue?: string;\n\n    /**\n     * Whether the text can be edited.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /** Whether the component is currently being edited. */\n    isEditing?: boolean;\n\n    /** Maximum number of characters allowed. Unlimited by default. */\n    maxLength?: number;\n\n    /** Minimum width in pixels of the input, when not `multiline`. */\n    minWidth?: number;\n\n    /**\n     * Whether the component supports multiple lines of text.\n     * This prop should not be changed during the component's lifetime.\n     *\n     * @default false\n     */\n    multiline?: boolean;\n\n    /**\n     * Maximum number of lines before scrolling begins, when `multiline`.\n     */\n    maxLines?: number;\n\n    /**\n     * Minimum number of lines (essentially minimum height), when `multiline`.\n     *\n     * @default 1\n     */\n    minLines?: number;\n\n    /**\n     * Placeholder text when there is no value.\n     *\n     * @default \"Click to Edit\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the entire text field should be selected on focus.\n     * If `false`, the cursor is placed at the end of the text.\n     * This prop is ignored on inputs with type other then text, search, url, tel and password. See https://html.spec.whatwg.org/multipage/input.html#do-not-apply for details.\n     *\n     * @default false\n     */\n    selectAllOnFocus?: boolean;\n\n    /**\n     * The type of input that should be shown, when not `multiline`.\n     */\n    type?: string;\n\n    /** Text value of controlled input. */\n    value?: string;\n\n    /** ID attribute to pass to the underlying element that contains the text contents. This allows for referencing via aria attributes */\n    contentId?: string;\n\n    /** Callback invoked when user cancels input with the `esc` key. Receives last confirmed value. */\n    onCancel?(value: string): void;\n\n    /** Callback invoked when user changes input in any way. */\n    onChange?(value: string): void;\n\n    /** Callback invoked when user confirms value with `enter` key or by blurring input. */\n    onConfirm?(value: string): void;\n\n    /** Callback invoked after the user enters edit mode. */\n    onEdit?(value: string | undefined): void;\n}\n\nexport interface IEditableTextState {\n    /** Pixel height of the input, measured from span size */\n    inputHeight?: number;\n    /** Pixel width of the input, measured from span size */\n    inputWidth?: number;\n    /** Whether the value is currently being edited */\n    isEditing?: boolean;\n    /** The last confirmed value */\n    lastValue?: string;\n    /** The controlled input value, may be different from prop during editing */\n    value?: string;\n}\n\nconst BUFFER_WIDTH_DEFAULT = 5;\nconst BUFFER_WIDTH_IE = 30;\n\nexport class EditableText extends AbstractPureComponent2<EditableTextProps, IEditableTextState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.EditableText`;\n\n    public static defaultProps: EditableTextProps = {\n        alwaysRenderInput: false,\n        confirmOnEnterKey: false,\n        defaultValue: \"\",\n        disabled: false,\n        maxLines: Infinity,\n        minLines: 1,\n        minWidth: 80,\n        multiline: false,\n        placeholder: \"Click to Edit\",\n        type: \"text\",\n    };\n\n    private inputElement: HTMLInputElement | HTMLTextAreaElement | null = null;\n\n    private valueElement: HTMLSpanElement | null = null;\n\n    private refHandlers = {\n        content: (spanElement: HTMLSpanElement | null) => {\n            this.valueElement = spanElement;\n        },\n        input: (input: HTMLInputElement | HTMLTextAreaElement | null) => {\n            if (input != null) {\n                this.inputElement = input;\n\n                // temporary fix for #3882\n                if (!this.props.alwaysRenderInput) {\n                    this.inputElement.focus();\n                }\n\n                if (this.state != null && this.state.isEditing) {\n                    const supportsSelection = inputSupportsSelection(input);\n                    if (supportsSelection) {\n                        const { length } = input.value;\n                        input.setSelectionRange(this.props.selectAllOnFocus ? 0 : length, length);\n                    }\n                    if (!supportsSelection || !this.props.selectAllOnFocus) {\n                        input.scrollLeft = input.scrollWidth;\n                    }\n                }\n            }\n        },\n    };\n\n    public constructor(props: EditableTextProps, context?: any) {\n        super(props, context);\n\n        const value = props.value == null ? props.defaultValue : props.value;\n        this.state = {\n            inputHeight: 0,\n            inputWidth: 0,\n            isEditing: props.isEditing === true && props.disabled === false,\n            lastValue: value,\n            value,\n        };\n    }\n\n    public render() {\n        const { alwaysRenderInput, disabled, multiline, contentId } = this.props;\n        const value = this.props.value ?? this.state.value;\n        const hasValue = value != null && value !== \"\";\n\n        const classes = classNames(\n            Classes.EDITABLE_TEXT,\n            Classes.intentClass(this.props.intent),\n            {\n                [Classes.DISABLED]: disabled,\n                [Classes.EDITABLE_TEXT_EDITING]: this.state.isEditing,\n                [Classes.EDITABLE_TEXT_PLACEHOLDER]: !hasValue,\n                [Classes.MULTILINE]: multiline,\n            },\n            this.props.className,\n        );\n\n        let contentStyle: React.CSSProperties;\n        if (multiline) {\n            // set height only in multiline mode when not editing\n            // otherwise we're measuring this element to determine appropriate height of text\n            contentStyle = { height: !this.state.isEditing ? this.state.inputHeight : undefined };\n        } else {\n            // minWidth only applies in single line mode (multiline == width 100%)\n            contentStyle = {\n                height: this.state.inputHeight,\n                lineHeight: this.state.inputHeight != null ? `${this.state.inputHeight}px` : undefined,\n                minWidth: this.props.minWidth,\n            };\n        }\n\n        // If we are always rendering an input, then NEVER make the container div focusable.\n        // Otherwise, make container div focusable when not editing, so it can still be tabbed\n        // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n        const tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0;\n\n        // we need the contents to be rendered while editing so that we can measure their height\n        // and size the container element responsively\n        const shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n\n        const spanProps: React.HTMLProps<HTMLSpanElement> = contentId != null ? { id: contentId } : {};\n\n        return (\n            <div className={classes} onFocus={this.handleFocus} tabIndex={tabIndex}>\n                {alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined}\n                {shouldHideContents ? undefined : (\n                    <span\n                        {...spanProps}\n                        className={Classes.EDITABLE_TEXT_CONTENT}\n                        ref={this.refHandlers.content}\n                        style={contentStyle}\n                    >\n                        {hasValue ? value : this.props.placeholder}\n                    </span>\n                )}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateInputDimensions();\n    }\n\n    public componentDidUpdate(prevProps: EditableTextProps, prevState: IEditableTextState) {\n        const newState: IEditableTextState = {};\n        // allow setting the value to undefined/null in controlled mode\n        if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n            newState.value = this.props.value;\n        }\n        if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n            newState.isEditing = this.props.isEditing;\n        }\n        if (this.props.disabled || (this.props.disabled == null && prevProps.disabled)) {\n            newState.isEditing = false;\n        }\n\n        this.setState(newState);\n\n        if (this.state.isEditing && !prevState.isEditing) {\n            this.props.onEdit?.(this.state.value);\n        }\n        // updateInputDimensions is an expensive method. Call it only when the props\n        // it depends on change\n        if (\n            this.state.value !== prevState.value ||\n            this.props.alwaysRenderInput !== prevProps.alwaysRenderInput ||\n            this.props.maxLines !== prevProps.maxLines ||\n            this.props.minLines !== prevProps.minLines ||\n            this.props.minWidth !== prevProps.minWidth ||\n            this.props.multiline !== prevProps.multiline\n        ) {\n            this.updateInputDimensions();\n        }\n    }\n\n    public cancelEditing = () => {\n        const { lastValue, value } = this.state;\n        this.setState({ isEditing: false, value: lastValue });\n        if (value !== lastValue) {\n            this.props.onChange?.(lastValue!);\n        }\n        this.props.onCancel?.(lastValue!);\n    };\n\n    public toggleEditing = () => {\n        if (this.state.isEditing) {\n            const { value } = this.state;\n            this.setState({ isEditing: false, lastValue: value });\n            this.props.onConfirm?.(value!);\n        } else if (!this.props.disabled) {\n            this.setState({ isEditing: true });\n        }\n    };\n\n    private handleFocus = () => {\n        const { alwaysRenderInput, disabled, selectAllOnFocus } = this.props;\n\n        if (!disabled) {\n            this.setState({ isEditing: true });\n        }\n\n        if (alwaysRenderInput && selectAllOnFocus && this.inputElement != null) {\n            const { length } = this.inputElement.value;\n            this.inputElement.setSelectionRange(0, length);\n        }\n    };\n\n    private handleTextChange = (event: React.FormEvent<HTMLElement>) => {\n        const value = (event.target as HTMLInputElement).value;\n        // state value should be updated only when uncontrolled\n        if (this.props.value == null) {\n            this.setState({ value });\n        }\n        this.props.onChange?.(value);\n    };\n\n    private handleKeyEvent = (event: React.KeyboardEvent<HTMLElement>) => {\n        // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n        /* eslint-disable-next-line deprecation/deprecation */\n        const { altKey, ctrlKey, metaKey, shiftKey, which } = event;\n        if (which === Keys.ESCAPE) {\n            this.cancelEditing();\n            return;\n        }\n\n        const hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n        if (which === Keys.ENTER) {\n            // prevent IE11 from full screening with alt + enter\n            // shift + enter adds a newline by default\n            if (altKey || shiftKey) {\n                event.preventDefault();\n            }\n\n            if (this.props.confirmOnEnterKey && this.props.multiline) {\n                if (event.target != null && hasModifierKey) {\n                    insertAtCaret(event.target as HTMLTextAreaElement, \"\\n\");\n                    this.handleTextChange(event);\n                } else {\n                    this.toggleEditing();\n                }\n            } else if (!this.props.multiline || hasModifierKey) {\n                this.toggleEditing();\n            }\n        }\n    };\n\n    private renderInput(value: string | undefined) {\n        const { disabled, maxLength, multiline, type, placeholder } = this.props;\n        const props: React.InputHTMLAttributes<HTMLInputElement | HTMLTextAreaElement> = {\n            className: Classes.EDITABLE_TEXT_INPUT,\n            disabled,\n            maxLength,\n            onBlur: this.toggleEditing,\n            onChange: this.handleTextChange,\n            onKeyDown: this.handleKeyEvent,\n            placeholder,\n            value,\n        };\n\n        const { inputHeight, inputWidth } = this.state;\n        if (inputHeight !== 0 && inputWidth !== 0) {\n            props.style = {\n                height: inputHeight,\n                lineHeight: !multiline && inputHeight != null ? `${inputHeight}px` : undefined,\n                width: multiline ? \"100%\" : inputWidth,\n            };\n        }\n\n        return multiline ? (\n            <textarea ref={this.refHandlers.input} {...props} />\n        ) : (\n            <input ref={this.refHandlers.input} type={type} {...props} />\n        );\n    }\n\n    private updateInputDimensions() {\n        if (this.valueElement != null) {\n            const { maxLines, minLines, minWidth, multiline } = this.props;\n            const { parentElement, textContent } = this.valueElement;\n            let { scrollHeight, scrollWidth } = this.valueElement;\n            const lineHeight = getLineHeight(this.valueElement);\n            // add one line to computed <span> height if text ends in newline\n            // because <span> collapses that trailing whitespace but <textarea> shows it\n            if (multiline && this.state.isEditing && /\\n$/.test(textContent ?? \"\")) {\n                scrollHeight += lineHeight;\n            }\n            if (lineHeight > 0) {\n                // line height could be 0 if the isNaN block from getLineHeight kicks in\n                scrollHeight = clamp(scrollHeight, minLines! * lineHeight, maxLines! * lineHeight);\n            }\n            // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n            // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n            scrollHeight = Math.max(scrollHeight, getFontSize(this.valueElement) + 1, getLineHeight(parentElement!));\n            // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n            // IE needs a larger buffer than other browsers.\n            scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n\n            this.setState({\n                inputHeight: scrollHeight,\n                inputWidth: Math.max(scrollWidth, minWidth!),\n            });\n            // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n            if (multiline && this.state.isEditing) {\n                this.setTimeout(() => (parentElement!.style.height = `${scrollHeight}px`));\n            }\n        }\n    }\n}\n\nfunction getFontSize(element: HTMLElement) {\n    const fontSize = getComputedStyle(element).fontSize;\n    return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element: HTMLElement) {\n    // getComputedStyle() => 18.0001px => 18\n    let lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10);\n    // this check will be true if line-height is a keyword like \"normal\"\n    if (isNaN(lineHeight)) {\n        // @see http://stackoverflow.com/a/18430767/6342931\n        const line = document.createElement(\"span\");\n        line.innerHTML = \"<br>\";\n        element.appendChild(line);\n        const singleLineHeight = element.offsetHeight;\n        line.innerHTML = \"<br><br>\";\n        const doubleLineHeight = element.offsetHeight;\n        element.removeChild(line);\n        // this can return 0 in edge cases\n        lineHeight = doubleLineHeight - singleLineHeight;\n    }\n    return lineHeight;\n}\n\nfunction insertAtCaret(el: HTMLTextAreaElement, text: string) {\n    const { selectionEnd, selectionStart, value } = el;\n    if (selectionStart >= 0) {\n        const before = value.substring(0, selectionStart);\n        const after = value.substring(selectionEnd, value.length);\n        const len = text.length;\n        el.value = `${before}${text}${after}`;\n        el.selectionStart = selectionStart + len;\n        el.selectionEnd = selectionStart + len;\n    }\n}\n\nfunction inputSupportsSelection(input: HTMLInputElement | HTMLTextAreaElement) {\n    switch (input.type) {\n        // HTMLTextAreaElement\n        case \"textarea\":\n            return true;\n        // HTMLInputElement\n        // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        case \"text\":\n        case \"search\":\n        case \"tel\":\n        case \"url\":\n        case \"password\":\n            return true;\n        default:\n            return false;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}