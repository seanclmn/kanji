{"ast":null,"code":"/* !\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractPureComponent2, DISPLAYNAME_PREFIX } from \"../../common\";\n/**\n * A stateful wrapper around the low-level <input> component which works around a\n * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input\n * receives CompositionEvents (for example, through IME composition) and has its value prop updated\n * asychronously. This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n *\n * Note: this component does not apply any Blueprint-specific styling.\n */\n\nvar AsyncControllableInput =\n/** @class */\nfunction (_super) {\n  __extends(AsyncControllableInput, _super);\n\n  function AsyncControllableInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      hasPendingUpdate: false,\n      isComposing: false,\n      nextValue: _this.props.value,\n      value: _this.props.value\n    };\n    _this.cancelPendingCompositionEnd = null;\n\n    _this.handleCompositionStart = function (e) {\n      var _a, _b, _c;\n\n      (_a = _this.cancelPendingCompositionEnd) === null || _a === void 0 ? void 0 : _a.call(_this);\n\n      _this.setState({\n        isComposing: true\n      });\n\n      (_c = (_b = _this.props).onCompositionStart) === null || _c === void 0 ? void 0 : _c.call(_b, e);\n    };\n\n    _this.handleCompositionEnd = function (e) {\n      var _a, _b; // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n      // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n      // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n      // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n      // passed without a new composition event starting.\n\n\n      _this.cancelPendingCompositionEnd = _this.setTimeout(function () {\n        return _this.setState({\n          isComposing: false\n        });\n      }, AsyncControllableInput.COMPOSITION_END_DELAY);\n      (_b = (_a = _this.props).onCompositionEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleChange = function (e) {\n      var _a, _b;\n\n      var value = e.target.value;\n\n      _this.setState({\n        nextValue: value\n      });\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    return _this;\n  }\n\n  AsyncControllableInput.getDerivedStateFromProps = function (nextProps, nextState) {\n    if (nextState.isComposing || nextProps.value === undefined) {\n      // don't derive anything from props if:\n      // - in uncontrolled mode, OR\n      // - currently composing, since we'll do that after composition ends\n      return null;\n    }\n\n    var userTriggeredUpdate = nextState.nextValue !== nextState.value;\n\n    if (userTriggeredUpdate) {\n      if (nextProps.value === nextState.nextValue) {\n        // parent has processed and accepted our update\n        if (nextState.hasPendingUpdate) {\n          return {\n            value: nextProps.value,\n            hasPendingUpdate: false\n          };\n        } else {\n          return {\n            value: nextState.nextValue\n          };\n        }\n      } else {\n        if (nextProps.value === nextState.value) {\n          // we have sent the update to our parent, but it has not been processed yet. just wait.\n          // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n          // causing the cursor to jump once the new value is accepted\n          return {\n            hasPendingUpdate: true\n          };\n        } // accept controlled update overriding user action\n\n\n        return {\n          value: nextProps.value,\n          nextValue: nextProps.value,\n          hasPendingUpdate: false\n        };\n      }\n    } else {\n      // accept controlled update, could be confirming or denying user action\n      return {\n        value: nextProps.value,\n        nextValue: nextProps.value,\n        hasPendingUpdate: false\n      };\n    }\n  };\n\n  AsyncControllableInput.prototype.render = function () {\n    var _a = this.state,\n        isComposing = _a.isComposing,\n        hasPendingUpdate = _a.hasPendingUpdate,\n        value = _a.value,\n        nextValue = _a.nextValue;\n\n    var _b = this.props,\n        inputRef = _b.inputRef,\n        restProps = __rest(_b, [\"inputRef\"]);\n\n    return React.createElement(\"input\", __assign({}, restProps, {\n      ref: inputRef,\n      // render the pending value even if it is not confirmed by a parent's async controlled update\n      // so that the cursor does not jump to the end of input as reported in\n      // https://github.com/palantir/blueprint/issues/4298\n      value: isComposing || hasPendingUpdate ? nextValue : value,\n      onCompositionStart: this.handleCompositionStart,\n      onCompositionEnd: this.handleCompositionEnd,\n      onChange: this.handleChange\n    }));\n  };\n\n  AsyncControllableInput.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".AsyncControllableInput\");\n  /**\n   * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n   * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n   */\n\n  AsyncControllableInput.COMPOSITION_END_DELAY = 10;\n  return AsyncControllableInput;\n}(AbstractPureComponent2);\n\nexport { AsyncControllableInput };","map":{"version":3,"mappings":"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","names":["React","AbstractPureComponent2","DISPLAYNAME_PREFIX","__extends","_this","hasPendingUpdate","isComposing","nextValue","props","value","e","cancelPendingCompositionEnd","_a","setState","onCompositionStart","_c","setTimeout","AsyncControllableInput","COMPOSITION_END_DELAY","onCompositionEnd","_b","target","onChange","nextProps","nextState","undefined","userTriggeredUpdate","state","inputRef","restProps","ref","handleCompositionStart","handleCompositionEnd","handleChange"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/components/forms/asyncControllableInput.tsx"],"sourcesContent":["/* !\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as React from \"react\";\n\nimport { AbstractPureComponent2, DISPLAYNAME_PREFIX } from \"../../common\";\n\nexport interface IAsyncControllableInputProps\n    extends React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement> {\n    inputRef?: React.LegacyRef<HTMLInputElement>;\n}\n\ntype InputValue = IAsyncControllableInputProps[\"value\"];\n\nexport interface IAsyncControllableInputState {\n    /**\n     * Whether we are in the middle of a composition event.\n     *\n     * @default false\n     */\n    isComposing: boolean;\n\n    /**\n     * The source of truth for the input value. This is not updated during IME composition.\n     * It may be updated by a parent component.\n     *\n     * @default \"\"\n     */\n    value: InputValue;\n\n    /**\n     * The latest input value, which updates during IME composition. Defaults to props.value.\n     */\n    nextValue: InputValue;\n\n    /**\n     * Whether there is a pending update we are expecting from a parent component.\n     *\n     * @default false\n     */\n    hasPendingUpdate: boolean;\n}\n\n/**\n * A stateful wrapper around the low-level <input> component which works around a\n * [React bug](https://github.com/facebook/react/issues/3926). This bug is reproduced when an input\n * receives CompositionEvents (for example, through IME composition) and has its value prop updated\n * asychronously. This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n *\n * Note: this component does not apply any Blueprint-specific styling.\n */\nexport class AsyncControllableInput extends AbstractPureComponent2<\n    IAsyncControllableInputProps,\n    IAsyncControllableInputState\n> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.AsyncControllableInput`;\n\n    /**\n     * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n     * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n     */\n    public static COMPOSITION_END_DELAY = 10;\n\n    public state: IAsyncControllableInputState = {\n        hasPendingUpdate: false,\n        isComposing: false,\n        nextValue: this.props.value,\n        value: this.props.value,\n    };\n\n    private cancelPendingCompositionEnd: (() => void) | null = null;\n\n    public static getDerivedStateFromProps(\n        nextProps: IAsyncControllableInputProps,\n        nextState: IAsyncControllableInputState,\n    ): Partial<IAsyncControllableInputState> | null {\n        if (nextState.isComposing || nextProps.value === undefined) {\n            // don't derive anything from props if:\n            // - in uncontrolled mode, OR\n            // - currently composing, since we'll do that after composition ends\n            return null;\n        }\n\n        const userTriggeredUpdate = nextState.nextValue !== nextState.value;\n\n        if (userTriggeredUpdate) {\n            if (nextProps.value === nextState.nextValue) {\n                // parent has processed and accepted our update\n                if (nextState.hasPendingUpdate) {\n                    return { value: nextProps.value, hasPendingUpdate: false };\n                } else {\n                    return { value: nextState.nextValue };\n                }\n            } else {\n                if (nextProps.value === nextState.value) {\n                    // we have sent the update to our parent, but it has not been processed yet. just wait.\n                    // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n                    // causing the cursor to jump once the new value is accepted\n                    return { hasPendingUpdate: true };\n                }\n                // accept controlled update overriding user action\n                return { value: nextProps.value, nextValue: nextProps.value, hasPendingUpdate: false };\n            }\n        } else {\n            // accept controlled update, could be confirming or denying user action\n            return { value: nextProps.value, nextValue: nextProps.value, hasPendingUpdate: false };\n        }\n    }\n\n    public render() {\n        const { isComposing, hasPendingUpdate, value, nextValue } = this.state;\n        const { inputRef, ...restProps } = this.props;\n        return (\n            <input\n                {...restProps}\n                ref={inputRef}\n                // render the pending value even if it is not confirmed by a parent's async controlled update\n                // so that the cursor does not jump to the end of input as reported in\n                // https://github.com/palantir/blueprint/issues/4298\n                value={isComposing || hasPendingUpdate ? nextValue : value}\n                onCompositionStart={this.handleCompositionStart}\n                onCompositionEnd={this.handleCompositionEnd}\n                onChange={this.handleChange}\n            />\n        );\n    }\n\n    private handleCompositionStart = (e: React.CompositionEvent<HTMLInputElement>) => {\n        this.cancelPendingCompositionEnd?.();\n        this.setState({ isComposing: true });\n        this.props.onCompositionStart?.(e);\n    };\n\n    private handleCompositionEnd = (e: React.CompositionEvent<HTMLInputElement>) => {\n        // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n        // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n        // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n        // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n        // passed without a new composition event starting.\n        this.cancelPendingCompositionEnd = this.setTimeout(\n            () => this.setState({ isComposing: false }),\n            AsyncControllableInput.COMPOSITION_END_DELAY,\n        );\n        this.props.onCompositionEnd?.(e);\n    };\n\n    private handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const { value } = e.target;\n\n        this.setState({ nextValue: value });\n        this.props.onChange?.(e);\n    };\n}\n"]},"metadata":{},"sourceType":"module"}