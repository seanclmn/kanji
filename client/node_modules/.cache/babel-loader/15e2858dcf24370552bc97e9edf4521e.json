{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Children } from \"react\";\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nvar SHOW_DIALOG_KEY = \"?\";\nexport var HotkeyScope;\n\n(function (HotkeyScope) {\n  HotkeyScope[\"LOCAL\"] = \"local\";\n  HotkeyScope[\"GLOBAL\"] = \"global\";\n})(HotkeyScope || (HotkeyScope = {}));\n\nvar HotkeysEvents =\n/** @class */\nfunction () {\n  function HotkeysEvents(scope) {\n    var _this = this;\n\n    this.scope = scope;\n    this.actions = [];\n\n    this.handleKeyDown = function (e) {\n      var combo = getKeyCombo(e);\n\n      var isTextInput = _this.isTextInput(e);\n\n      if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n        if (isHotkeysDialogShowing()) {\n          hideHotkeysDialogAfterDelay();\n        } else {\n          showHotkeysDialog(_this.actions.map(function (action) {\n            return action.props;\n          }));\n        }\n\n        return;\n      } else if (isHotkeysDialogShowing()) {\n        return;\n      }\n\n      _this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    this.handleKeyUp = function (e) {\n      if (isHotkeysDialogShowing()) {\n        return;\n      }\n\n      _this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n  }\n\n  HotkeysEvents.prototype.count = function () {\n    return this.actions.length;\n  };\n\n  HotkeysEvents.prototype.clear = function () {\n    this.actions = [];\n  };\n\n  HotkeysEvents.prototype.setHotkeys = function (props) {\n    var _this = this;\n\n    var actions = [];\n    Children.forEach(props.children, function (child) {\n      if (isElementOfType(child, Hotkey) && _this.isScope(child.props)) {\n        actions.push({\n          combo: parseKeyCombo(child.props.combo),\n          props: child.props\n        });\n      }\n    });\n    this.actions = actions;\n  };\n\n  HotkeysEvents.prototype.invokeNamedCallbackIfComboRecognized = function (combo, callbackName, e) {\n    var _a, _b;\n\n    var isTextInput = this.isTextInput(e);\n\n    for (var _i = 0, _c = this.actions; _i < _c.length; _i++) {\n      var action = _c[_i];\n      var shouldIgnore = isTextInput && !action.props.allowInInput || action.props.disabled;\n\n      if (!shouldIgnore && comboMatches(action.combo, combo)) {\n        if (action.props.preventDefault) {\n          e.preventDefault();\n        }\n\n        if (action.props.stopPropagation) {\n          // set a flag just for unit testing. not meant to be referenced in feature work.\n          e.isPropagationStopped = true;\n          e.stopPropagation();\n        }\n\n        (_b = (_a = action.props)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n      }\n    }\n  };\n\n  HotkeysEvents.prototype.isScope = function (props) {\n    return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n  };\n\n  HotkeysEvents.prototype.isTextInput = function (e) {\n    var elem = e.target; // we check these cases for unit testing, but this should not happen\n    // during normal operation\n\n    if (elem == null || elem.closest == null) {\n      return false;\n    }\n\n    var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n    if (editable == null) {\n      return false;\n    } // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n\n\n    if (editable.tagName.toLowerCase() === \"input\") {\n      var inputType = editable.type;\n\n      if (inputType === \"checkbox\" || inputType === \"radio\") {\n        return false;\n      }\n    } // don't let read-only fields prevent hotkey behavior\n\n\n    if (editable.readOnly) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return HotkeysEvents;\n}();\n\nexport { HotkeysEvents };","map":{"version":3,"mappings":"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","names":["Children","isElementOfType","Hotkey","comboMatches","getKeyCombo","parseKeyCombo","hideHotkeysDialogAfterDelay","isHotkeysDialogShowing","showHotkeysDialog","SHOW_DIALOG_KEY","HotkeyScope","scope","e","combo","isTextInput","_this","actions","map","props","invokeNamedCallbackIfComboRecognized","HotkeysEvents","length","forEach","children","child","isScope","push","callbackName","_i","action","shouldIgnore","allowInInput","disabled","preventDefault","stopPropagation","isPropagationStopped","_b","global","GLOBAL","LOCAL","elem","target","closest","editable","tagName","toLowerCase","inputType","type","readOnly"],"sources":["/Users/seancoleman/Projects/kanji/node_modules/@blueprintjs/core/src/components/hotkeys/hotkeysEvents.ts"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Children, ReactNode } from \"react\";\n\nimport { isElementOfType } from \"../../common/utils\";\nimport { Hotkey, IHotkeyProps } from \"./hotkey\";\nimport { comboMatches, getKeyCombo, IKeyCombo, parseKeyCombo } from \"./hotkeyParser\";\nimport { hideHotkeysDialogAfterDelay, isHotkeysDialogShowing, showHotkeysDialog } from \"./hotkeysDialog\";\nimport { IHotkeysProps } from \"./hotkeysTypes\";\n\nconst SHOW_DIALOG_KEY = \"?\";\n\nexport enum HotkeyScope {\n    LOCAL = \"local\",\n    GLOBAL = \"global\",\n}\n\nexport interface IHotkeyAction {\n    combo: IKeyCombo;\n    props: IHotkeyProps;\n}\n\nexport class HotkeysEvents {\n    private actions = [] as IHotkeyAction[];\n\n    public constructor(private scope: HotkeyScope) {}\n\n    public count() {\n        return this.actions.length;\n    }\n\n    public clear() {\n        this.actions = [];\n    }\n\n    public setHotkeys(props: IHotkeysProps & { children?: ReactNode }) {\n        const actions = [] as IHotkeyAction[];\n        Children.forEach(props.children, (child: ReactNode) => {\n            if (isElementOfType(child, Hotkey) && this.isScope(child.props)) {\n                actions.push({\n                    combo: parseKeyCombo(child.props.combo),\n                    props: child.props,\n                });\n            }\n        });\n        this.actions = actions;\n    }\n\n    public handleKeyDown = (e: KeyboardEvent) => {\n        const combo = getKeyCombo(e);\n        const isTextInput = this.isTextInput(e);\n\n        if (!isTextInput && comboMatches(parseKeyCombo(SHOW_DIALOG_KEY), combo)) {\n            if (isHotkeysDialogShowing()) {\n                hideHotkeysDialogAfterDelay();\n            } else {\n                showHotkeysDialog(this.actions.map(action => action.props));\n            }\n            return;\n        } else if (isHotkeysDialogShowing()) {\n            return;\n        }\n\n        this.invokeNamedCallbackIfComboRecognized(combo, \"onKeyDown\", e);\n    };\n\n    public handleKeyUp = (e: KeyboardEvent) => {\n        if (isHotkeysDialogShowing()) {\n            return;\n        }\n        this.invokeNamedCallbackIfComboRecognized(getKeyCombo(e), \"onKeyUp\", e);\n    };\n\n    private invokeNamedCallbackIfComboRecognized(\n        combo: IKeyCombo,\n        callbackName: \"onKeyDown\" | \"onKeyUp\",\n        e: KeyboardEvent,\n    ) {\n        const isTextInput = this.isTextInput(e);\n        for (const action of this.actions) {\n            const shouldIgnore = (isTextInput && !action.props.allowInInput) || action.props.disabled;\n            if (!shouldIgnore && comboMatches(action.combo, combo)) {\n                if (action.props.preventDefault) {\n                    e.preventDefault();\n                }\n                if (action.props.stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    (e as any).isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                action.props[callbackName]?.(e);\n            }\n        }\n    }\n\n    private isScope(props: IHotkeyProps) {\n        return (props.global ? HotkeyScope.GLOBAL : HotkeyScope.LOCAL) === this.scope;\n    }\n\n    private isTextInput(e: KeyboardEvent) {\n        const elem = e.target as HTMLElement;\n        // we check these cases for unit testing, but this should not happen\n        // during normal operation\n        if (elem == null || elem.closest == null) {\n            return false;\n        }\n\n        const editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n\n        if (editable == null) {\n            return false;\n        }\n\n        // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n        if (editable.tagName.toLowerCase() === \"input\") {\n            const inputType = (editable as HTMLInputElement).type;\n            if (inputType === \"checkbox\" || inputType === \"radio\") {\n                return false;\n            }\n        }\n\n        // don't let read-only fields prevent hotkey behavior\n        if ((editable as HTMLInputElement).readOnly) {\n            return false;\n        }\n\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}